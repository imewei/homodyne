# Diff 3: cmc/coordinator.py - Add single-shard identity combination
# Apply with: git apply docs/refactor/diffs/03-cmc-coordinator-single-shard.diff
#
# This diff:
# - Adds identity combination for single-shard case
# - Ensures num_shards >= 1 always
# - Adds single-shard logging

--- a/homodyne/optimization/cmc/coordinator.py
+++ b/homodyne/optimization/cmc/coordinator.py
@@ -588,16 +588,32 @@ class CMCCoordinator:
         # =====================================================================
-        # Step 3: Combine subposteriors
+        # Step 3: Combine subposteriors (or identity for single shard)
         # =====================================================================
         logger.info("=" * 70)
         logger.info("STEP 3: Combining subposteriors")
         logger.info("=" * 70)

-        combination_section = self.config.get("combination")
-        if not isinstance(combination_section, dict) or not combination_section:
-            combination_section = self.config.get("cmc", {}).get("combination", {})
-
-        combination_method = combination_section.get("method", "weighted")
-        fallback_enabled = combination_section.get("fallback_enabled", True)
-
-        validation_section = self.config.get("validation")
-        if not isinstance(validation_section, dict) or not validation_section:
-            validation_section = self.config.get("cmc", {}).get("validation", {})
-
-        combination_start = time.time()
-        combined_posterior = combine_subposteriors(
-            shard_results,
-            method=combination_method,
-            fallback_enabled=fallback_enabled,
-            diagnostics_config=validation_section,
-        )
-        combination_time = time.time() - combination_start
+        # Single-shard case: Use identity combination (no consensus needed)
+        if len(shard_results) == 1:
+            logger.info("Single shard - using identity combination (no consensus needed)")
+            shard_samples = shard_results[0].get("samples")
+            if shard_samples is None:
+                raise RuntimeError("Single shard returned no samples")
+
+            combined_posterior = {
+                "samples": shard_samples,
+                "mean": np.mean(shard_samples, axis=0),
+                "cov": np.cov(shard_samples, rowvar=False) if shard_samples.shape[0] > 1 else np.eye(shard_samples.shape[1]),
+                "method": "identity",  # Mark as single-shard
+            }
+            combination_time = 0.0
+            logger.info("✓ Single-shard identity combination complete (0.00s)")
+        else:
+            # Multi-shard: Use standard combination
+            combination_section = self.config.get("combination")
+            if not isinstance(combination_section, dict) or not combination_section:
+                combination_section = self.config.get("cmc", {}).get("combination", {})
+
+            combination_method = combination_section.get("method", "weighted")
+            fallback_enabled = combination_section.get("fallback_enabled", True)
+
+            validation_section = self.config.get("validation")
+            if not isinstance(validation_section, dict) or not validation_section:
+                validation_section = self.config.get("cmc", {}).get("validation", {})
+
+            combination_start = time.time()
+            combined_posterior = combine_subposteriors(
+                shard_results,
+                method=combination_method,
+                fallback_enabled=fallback_enabled,
+                diagnostics_config=validation_section,
+            )
+            combination_time = time.time() - combination_start
+
+            logger.info(
+                f"✓ Combined posteriors using method: {combined_posterior['method']} "
+                f"(requested: {combination_method})"
+            )
+            logger.info(f"  Combination time: {combination_time:.2f}s")

-        logger.info(
-            f"✓ Combined posteriors using method: {combined_posterior['method']} "
-            f"(requested: {combination_method})"
-        )
-        logger.info(f"  Combination time: {combination_time:.2f}s")

         # =====================================================================
         # Step 4: Validate results
@@ -664,10 +680,14 @@ class CMCCoordinator:
     def _calculate_num_shards(self, dataset_size: int) -> int:
         """Calculate optimal number of shards.

+        Always returns at least 1 (CMC-only architecture).
+        Single-shard mode is equivalent to standalone NUTS.
+
         Parameters
         ----------
         dataset_size : int
             Total number of data points

         Returns
         -------
         int
             Optimal number of shards
         """
         # Allow user override
         user_num_shards = (
             self.config.get("cmc", {}).get("sharding", {}).get("num_shards")
         )
         if user_num_shards is not None:
-            logger.info(f"Using user-specified num_shards: {user_num_shards}")
-            return user_num_shards
+            final_shards = max(1, user_num_shards)
+            logger.info(f"Using user-specified num_shards: {final_shards}")
+            return final_shards

         # Calculate automatically
         target_shard_size_gpu = (
             self.config.get("cmc", {})
             .get("sharding", {})
             .get("target_shard_size_gpu", 100_000)
         )
         target_shard_size_cpu = (
             self.config.get("cmc", {})
             .get("sharding", {})
             .get("target_shard_size_cpu", 2_000_000)
         )
         min_shard_size = (
             self.config.get("cmc", {}).get("sharding", {}).get("min_shard_size", 10_000)
         )

-        return calculate_optimal_num_shards(
+        calculated_shards = calculate_optimal_num_shards(
             dataset_size=dataset_size,
             hardware_config=self.hardware_config,
             target_shard_size_gpu=target_shard_size_gpu,
             target_shard_size_cpu=target_shard_size_cpu,
             min_shard_size=min_shard_size,
         )
+
+        # Ensure at least 1 shard (CMC-only architecture)
+        return max(1, calculated_shards)
