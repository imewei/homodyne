diff --git a/homodyne/core/physics_cmc.py b/homodyne/core/physics_cmc.py
index 0942a2e..f6e7c61 100644
--- a/homodyne/core/physics_cmc.py
+++ b/homodyne/core/physics_cmc.py
@@ -213,14 +213,26 @@ def _compute_g1_diffusion_elementwise(
     D_t2 = _calculate_diffusion_coefficient_impl_jax(t2, D0, alpha, D_offset)
 
     # Trapezoidal integration: ∫D(t)dt ≈ |t2-t1| * (D(t1) + D(t2)) / 2
-    D_integral_elementwise = jnp.abs(t2 - t1) * (D_t1 + D_t2) / 2.0
+    # CRITICAL FIX: Use smooth abs() approximation for gradient stability in MCMC NUTS
+    # jnp.abs() has undefined gradient at x=0 (when t1 ≈ t2), causing NaN in NUTS backprop
+    # Solution: sqrt(x² + ε) ≈ |x| but differentiable everywhere
+    # Same fix as physics_nlsq.py:240 - this is why NLSQ works but MCMC failed!
+    epsilon_abs = 1e-20
+    time_diff_smooth = jnp.sqrt((t2 - t1)**2 + epsilon_abs)
+    D_integral_elementwise = time_diff_smooth * (D_t1 + D_t2) / 2.0
 
     # Compute g1 using log-space for numerical stability
     log_g1 = -wavevector_q_squared_half_dt * D_integral_elementwise
     log_g1_clipped = jnp.clip(log_g1, -100.0, 0.0)
     g1_diffusion = jnp.exp(log_g1_clipped)
 
-    return g1_diffusion  # Shape: (n_points,)
+    # CRITICAL FIX: Physical constraint |g1| ≤ 1.0 (normalized correlation function)
+    # Numerical errors can push g1 slightly above 1.0, causing unphysical amplification
+    # in g2 = 1 + (g1)² and creating gradient issues for MCMC NUTS sampler
+    # Same fix as physics_nlsq.py:325
+    g1_safe = jnp.minimum(g1_diffusion, 1.0)
+
+    return g1_safe  # Shape: (n_points,)
 
 
 @jit
@@ -276,7 +288,13 @@ def _compute_g1_shear_elementwise(
     )
 
     # Trapezoidal integration: ∫γ̇(t)dt ≈ |t2-t1| * (γ̇(t1) + γ̇(t2)) / 2
-    gamma_integral_elementwise = jnp.abs(t2 - t1) * (gamma_t1 + gamma_t2) / 2.0
+    # CRITICAL FIX: Use smooth abs() approximation for gradient stability in MCMC NUTS
+    # jnp.abs() has undefined gradient at x=0 (when t1 ≈ t2), causing NaN in NUTS backprop
+    # Solution: sqrt(x² + ε) ≈ |x| but differentiable everywhere
+    # Same issue and fix as diffusion integration (line 220-221)
+    epsilon_abs = 1e-20
+    time_diff_smooth = jnp.sqrt((t2 - t1)**2 + epsilon_abs)
+    gamma_integral_elementwise = time_diff_smooth * (gamma_t1 + gamma_t2) / 2.0
 
     # phi_unique is already filtered to unique values by caller (compute_g1_total)
     # No need for jnp.unique() here (causes JAX concretization error during JIT)
