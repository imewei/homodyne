# ==============================================================================
# HOMODYNE LAMINAR FLOW CONFIGURATION TEMPLATE
# ==============================================================================
# Production-ready template for laminar flow (nonequilibrium) analysis.
# 7-parameter model:
#   D(t) = D₀·t^α + D_offset
#   γ̇(t) = γ̇₀·t^β + γ̇_offset
#
# Use for: Taylor-Couette flow, shear cells, rheology, time-dependent shear
# Parameter count: 7 physical + 2 × N_angles scaling = 7 + 2N total
#
# For comprehensive documentation of all parameters, see:
#   homodyne_master_template.yaml
#
# VERSION: 2.22.1
# UPDATED: 2026-02-19
# ==============================================================================

# ==============================================================================
# METADATA
# ==============================================================================
metadata:
  config_version: "2.22.1"
  description: "Laminar flow analysis - 7-parameter model"
  analysis_mode: "laminar_flow"
  parameter_count: 7

  # Physics model
  physics_model: "D(t) = D₀·t^α + D_offset"
  shear_model: "γ̇(t) = γ̇₀·t^β + γ̇_offset"

  # Numerical methods
  integration_method: "discrete_numerical"
  diagonal_correction: "mandatory"
  nlsq_cmc_physics_match: true

  # Template classification
  template_type: "production_ready"
  complexity: "focused"

  # Auto-filled by CLI
  generated_at: null
  generated_by: null

# ==============================================================================
# ANALYSIS MODE
# ==============================================================================
analysis_mode: "laminar_flow"

# ==============================================================================
# ANALYZER PARAMETERS
# ==============================================================================
analyzer_parameters:
  dt: 0.001 # Time step [seconds]
  start_frame: 1 # Starting frame (1-indexed)
  end_frame: 2000 # Ending frame (inclusive)

  scattering:
    wavevector_q: 0.0054 # Wave vector [Å⁻¹]

  geometry:
    stator_rotor_gap: 2000000 # Gap [Å] (200 microns)

# ==============================================================================
# ANALYSIS SETTINGS
# ==============================================================================
analysis_settings:
  model_description:
    type: "nonequilibrium_laminar_flow"
    parameters: 7
    physics: "Time-dependent diffusion with shear; C2 diagonal correction enforced"

# ==============================================================================
# EXPERIMENTAL DATA
# ==============================================================================
experimental_data:
  file_path: "./data/sample/experiment.hdf"

  # Legacy composite path
  data_folder_path: "./data/sample/"
  data_file_name: "experiment.hdf"

  # Phi angles
  phi_angles_path: "./data/sample/"
  phi_angles_file: "phi_angles_list.txt"

  # Caching
  cache_file_path: "./data/sample/"
  cache_filename_template: "cached_c2_flow_q{wavevector_q:.4f}_frames_{start_frame}_{end_frame}.npz"
  cache_compression: true

  # Format
  data_type: "float64"
  file_format: "HDF5"
  exchange_key: "exchange"

# ==============================================================================
# PHI ANGLE FILTERING
# ==============================================================================
# For laminar flow: parallel (0°) and perpendicular (90°) angles capture
# directional flow information optimally.
phi_filtering:
  enabled: true

  target_ranges:
    - min_angle: -10.0
      max_angle: 10.0
      description: "Parallel to flow"
    - min_angle: 85.0
      max_angle: 95.0
      description: "Perpendicular to flow"
    # Optional additional ranges:
    # - min_angle: -95.0
    #   max_angle: -85.0
    #   description: "Perpendicular (opposite side)"

  fallback_to_all_angles: true
  algorithm: "range_based"
  tolerance: 3.0

  quality_control:
    min_angles_required: 1
    max_angle_spread: 36.0
    validate_coverage: true
    require_orthogonal_angles: true # Recommended for flow

# ==============================================================================
# INITIAL PARAMETERS
# ==============================================================================
# Total = 7 physical + 2 × N_angles (per-angle contrast + offset)
# Example: 3 angles → 13 parameters
initial_parameters:
  parameter_names:
    - D0 # Diffusion prefactor [Å²/s]
    - alpha # Anomalous exponent
    - D_offset # Baseline diffusion [Å²/s]
    - gamma_dot_t0 # Shear rate prefactor [s⁻¹]
    - beta # Shear exponent
    - gamma_dot_t_offset # Baseline shear [s⁻¹]
    - phi0 # Flow angle offset [degrees]

  # Initial values: null = mid-bounds, or list of 7 floats
  values: null
  # Example: [1000.0, 0.5, 10.0, 0.01, 0.0, 0.0, 0.0]

  # Per-angle scaling (one value per filtered angle)
  # v2.17.0+: Quantile-based initialization computes robust initial values
  # from experimental data using quantile statistics when null
  per_angle_scaling:
    contrast: null # null = quantile-based init, or [0.05, 0.06] for 2 angles
    offset: null # null = quantile-based init, or [1.0, 0.99] for 2 angles

  units:
    - "Å²/s"
    - "dimensionless"
    - "Å²/s"
    - "s⁻¹"
    - "dimensionless"
    - "s⁻¹"
    - "degrees"

  # Optional: Optimize subset of parameters
  active_parameters: null # e.g., ["D0", "alpha", "gamma_dot_t0"]

  # Optional: Fix parameters at specific values
  fixed_parameters: null # e.g., {"beta": 0.0, "gamma_dot_t_offset": 0.0}

# ==============================================================================
# PARAMETER SPACE
# ==============================================================================
parameter_space:
  model: "laminar_flow"

  bounds:
    # Scaling parameters
    - name: contrast
      min: 0.0
      max: 1.0
      type: TruncatedNormal

    - name: offset
      min: 0.5
      max: 1.5
      type: TruncatedNormal

    # Diffusion parameters
    - name: D0
      min: 100.0
      max: 100000.0
      type: TruncatedNormal
      prior_mu: 1000.0
      prior_sigma: 1000.0
      unit: "Å²/s"

    - name: alpha
      min: -2.0
      max: 2.0
      type: TruncatedNormal
      prior_mu: 0.5 # Superdiffusion common under shear
      prior_sigma: 0.5
      unit: "dimensionless"

    - name: D_offset
      min: -100000.0
      max: 100000.0
      type: TruncatedNormal
      prior_mu: 10.0
      prior_sigma: 200.0
      unit: "Å²/s"

    # Flow parameters
    - name: gamma_dot_t0
      min: 1.0e-6
      max: 0.5
      type: TruncatedNormal
      prior_mu: 0.01
      prior_sigma: 0.1
      unit: "s⁻¹"

    - name: beta
      min: -2.0
      max: 2.0
      type: TruncatedNormal
      prior_mu: 0.0 # Constant shear common
      prior_sigma: 0.5
      unit: "dimensionless"

    - name: gamma_dot_t_offset
      min: -0.1
      max: 0.1
      type: TruncatedNormal
      prior_mu: 0.0
      prior_sigma: 0.02
      unit: "s⁻¹"

    - name: phi0
      min: -10.0 # Tight bounds for MCMC convergence
      max: 10.0
      type: TruncatedNormal
      prior_mu: 0.0
      prior_sigma: 5.0
      unit: "degrees"

  # Data-driven priors for MCMC (optional)
  priors:
    contrast:
      dist_type: TruncatedNormal
      mu: 0.27
      sigma: 0.15
      min_val: 0.0
      max_val: 1.0

    offset:
      dist_type: TruncatedNormal
      mu: 1.0
      sigma: 0.15
      min_val: 0.5
      max_val: 1.5

# ==============================================================================
# OPTIMIZATION
# ==============================================================================
optimization:
  method: "nlsq"

  # ===========================================================================
  # NLSQ - Trust-Region Nonlinear Least Squares
  # ===========================================================================
  nlsq:
    workflow: "auto"
    goal: "quality"

    # Memory configuration
    memory_fraction: 0.75 # Use 75% of available RAM
    # memory_threshold_gb: 48.0       # OR: explicit threshold

    # Convergence settings
    max_iterations: 100
    tolerance: 1.0e-8 # Function tolerance (ftol)
    xtol: 1.0e-8 # Parameter tolerance
    gtol: 1.0e-8 # Gradient tolerance
    trust_region_scale: 1.0
    verbose: false

    # Loss function
    loss: "soft_l1" # Recommended for XPCS data

    # Parameter scaling (CRITICAL for laminar flow)
    # Compute dataset-specific values: python scripts/diagnose_gradients.py
    x_scale_map: null # null = auto, or explicit values:
    # x_scale_map:
    #   D0: 1.20
    #   alpha: 0.000761
    #   D_offset: 1.13
    #   gamma_dot_t0: 0.00000371
    #   beta: 0.000314
    #   gamma_dot_t_offset: 0.0000000930
    #   phi0: 0.739

    # Progress
    progress:
      enable: true
      verbose: 1
      log_interval: 10

    # Diagnostics
    diagnostics:
      enabled: false
      sample_size: 2048
      check_gradients: true
      log_jacobian_norms: false

    # -------------------------------------------------------------------------
    # HYBRID STREAMING (>10M points)
    # -------------------------------------------------------------------------
    hybrid_streaming:
      enable: true
      normalize: true
      normalization_strategy: "auto"
      warmup_iterations: 200
      max_warmup_iterations: 500
      warmup_learning_rate: 0.001
      gauss_newton_max_iterations: 100
      gauss_newton_tol: 1.0e-8
      chunk_size: 10000
      trust_region_initial: 1.0
      regularization_factor: 1.0e-10
      enable_checkpoints: true
      checkpoint_frequency: 100
      validate_numerics: true
      verbose: 1
      log_frequency: 1

      # 4-Layer Defense Strategy
      enable_warm_start_detection: true
      warm_start_threshold: 0.01
      enable_adaptive_warmup_lr: true
      warmup_lr_refinement: 1.0e-6
      warmup_lr_careful: 1.0e-5
      enable_cost_guard: true
      cost_increase_tolerance: 0.05
      enable_step_clipping: true
      max_warmup_step_size: 0.1

    # -------------------------------------------------------------------------
    # ANTI-DEGENERACY DEFENSE SYSTEM
    # -------------------------------------------------------------------------
    # Prevents gradient cancellation and per-angle parameter absorption.
    # CRITICAL: hierarchical.enable MUST be true for shear_weighting to work!
    anti_degeneracy:
      enable: true
      # Per-angle mode selection (v2.18.0+):
      # Controls dimensionality reduction for per-angle contrast/offset.
      # Same logic as CMC per-angle mode (except NLSQ also has "fourier").
      #
      #   "auto" (RECOMMENDED): Auto-selects based on n_phi threshold.
      #     When n_phi >= threshold: Estimates per-angle values from quantile
      #     analysis, AVERAGES them to single value, broadcasts to all angles.
      #     Results in 9-param optimization (7 physical + 2 averaged scaling).
      #
      #   "constant": Per-angle values from quantile estimation, used DIRECTLY.
      #     Different fixed value per angle (NOT averaged, NOT optimized).
      #     Results in physical-only optimization (7 params).
      #
      #   "fourier": Fourier basis for smooth angle variation (NLSQ only).
      #     Configured via fourier_order and fourier_auto_threshold.
      #
      #   "individual": Independent per-angle params, optimized during fitting.
      #     Prone to absorption with many angles. Use with caution.
      #     Results in 7 + 2*N_phi parameters.
      #
      per_angle_mode: "auto"
      constant_scaling_threshold: 3 # Use constant when n_phi >= this

      # Fourier reparameterization (flat keys at anti_degeneracy level)
      fourier_order: 2         # Number of Fourier harmonics
      fourier_auto_threshold: 6 # Min angles for Fourier mode

      # REQUIRED for shear_weighting
      hierarchical:
        enable: true
        max_outer_iterations: 5
        outer_tolerance: 1.0e-6
        physical_max_iterations: 100
        per_angle_max_iterations: 50

      regularization:
        enable: false
        mode: "relative"
        lambda: 1.0
        target_cv: 0.10
        target_contribution: 0.10
        max_cv: 0.20
        auto_tune_lambda: true

      gradient_monitoring:
        enable: true
        ratio_threshold: 0.01
        consecutive_triggers: 5
        response: "hierarchical"

      # Shear-Sensitivity Weighting (prevents gradient cancellation)
      # Requires hierarchical.enable: true
      shear_weighting:
        enable: true
        alpha: 1.0
        min_weight: 0.3
        update_frequency: 50
        normalize: true

    # -------------------------------------------------------------------------
    # MULTI-START OPTIMIZATION
    # -------------------------------------------------------------------------
    # DISABLED when CMA-ES is enabled - they serve the same purpose (global search)
    multi_start:
      enable: false # OFF when using CMA-ES (redundant)
      n_starts: 10
      seed: 42
      sampling_strategy: "latin_hypercube"
      n_workers: 0
      use_screening: true
      screen_keep_fraction: 0.5
      refine_top_k: 3
      refinement_ftol: 1.0e-12
      degeneracy_threshold: 0.1

    # -------------------------------------------------------------------------
    # CMA-ES GLOBAL OPTIMIZATION (NLSQ 0.6.4+)
    # -------------------------------------------------------------------------
    # RECOMMENDED for laminar_flow with multi-scale parameters
    # (D₀ ~ 1e4 vs γ̇₀ ~ 1e-3, scale ratio > 1e7)
    # Requires: pip install nlsq[evosax]
    cmaes:
      enable: true # RECOMMENDED for laminar_flow
      preset: "cmaes-global" # "cmaes-fast" (50) | "cmaes" (100) | "cmaes-global" (200+)
      max_generations: 300 # 300 for 13-param space convergence
      sigma: 0.5 # Broader initial search, refined by CMA-ES
      popsize: 40 # Larger population for 13-param (default ~11)
      tol_fun: 1.0e-8
      tol_x: 1.0e-8
      restart_strategy: "bipop"
      max_restarts: 20 # More restarts to escape local minima
      population_batch_size: null
      data_chunk_size: null
      memory_limit_gb: 8.0
      auto_select: true
      scale_threshold: 1000.0

      # CMA-ES Parameter Normalization (v2.16.0)
      normalize: true            # Enable bounds-based normalization
      normalization_epsilon: 1.0e-12  # Prevent division by zero

      # Post-CMA-ES refinement
      refine_with_nlsq: true
      refinement_workflow: "auto"
      refinement_ftol: 1.0e-10
      refinement_xtol: 1.0e-10
      refinement_gtol: 1.0e-10
      refinement_max_nfev: 500
      refinement_loss: "linear"

    # -------------------------------------------------------------------------
    # FIT QUALITY VALIDATION (v2.16.0+)
    # -------------------------------------------------------------------------
    quality_validation:
      enable: true
      reduced_chi_squared_threshold: 10.0
      warn_on_max_restarts: true
      warn_on_bounds_hit: true
      warn_on_convergence_failure: true
      bounds_tolerance: 1.0e-9

  # ===========================================================================
  # STREAMING (>100M points)
  # ===========================================================================
  streaming:
    enable_checkpoints: true
    checkpoint_dir: "./checkpoints"
    checkpoint_frequency: 10
    resume_from_checkpoint: true
    keep_last_checkpoints: 3
    enable_fault_tolerance: true
    max_retries_per_batch: 2
    min_success_rate: 0.5
    batch_size: null
    adaptive_batching: true

  # ===========================================================================
  # STRATIFICATION
  # ===========================================================================
  stratification:
    enabled: "auto"
    target_chunk_size: 100000
    max_imbalance_ratio: 5.0
    force_sequential_fallback: false
    check_memory_safety: true
    use_index_based: false
    collect_diagnostics: false
    log_diagnostics: false

  # ===========================================================================
  # SEQUENTIAL FALLBACK
  # ===========================================================================
  sequential:
    min_success_rate: 0.5
    weighting: "inverse_variance"

  # ===========================================================================
  # RECOVERY
  # ===========================================================================
  recovery:
    enable: true
    max_attempts: 3
    lr_decay: 0.5
    lambda_growth: 2.0
    trust_decay: 0.5
    log_retries: true

  # ===========================================================================
  # MCMC - Base Configuration
  # ===========================================================================
  mcmc:
    backend: "numpyro"
    num_warmup: 500 # Aligned with per_shard_mcmc
    num_samples: 1500
    num_chains: 2
    progress_bar: true
    target_accept_prob: 0.90
    max_tree_depth: 12
    dense_mass_matrix: true

    initial_values:
      phi: {}
      percentile_fallback:
        contrast_low_pct: 5
        contrast_high_pct: 95
        offset_pct: 50

  # ===========================================================================
  # CMC - Consensus Monte Carlo
  # ===========================================================================
  # AUTOMATIC NLSQ WARM-START (v2.20.0):
  #   CLI: homodyne --method cmc → NLSQ runs first automatically
  #   Reduces divergence rate from ~28% to <5% for laminar_flow
  #   Disable with --no-nlsq-warmstart (NOT recommended for 7-param model)
  #
  cmc:
    enable: "auto"
    min_points_for_cmc: 100000 # Lower for 7-parameter model
    run_id: null
    backend: "jax"

    # Anti-degeneracy: Per-angle scaling mode (v2.18.0+)
    # Controls how per-angle contrast/offset are handled in CMC.
    # Same logic as NLSQ per-angle mode (except CMC does not have "fourier").
    #
    #   "auto" (RECOMMENDED): Auto-selects based on n_phi threshold.
    #     When n_phi >= threshold: Estimates per-angle values from quantile
    #     analysis, AVERAGES them to single value, broadcasts to all angles.
    #     Reduces to 8 params (7 physical + 1 sigma).
    #
    #   "constant": Per-angle values from quantile estimation, used DIRECTLY.
    #     Different fixed value per angle (NOT averaged, NOT sampled).
    #     Reduces to 8 params (7 physical + 1 sigma).
    #
    #   "individual": Independent contrast + offset per angle, all sampled.
    #     May cause parameter absorption degeneracy with many angles.
    #
    per_angle_mode: "auto"
    constant_scaling_threshold: 3 # Use constant when n_phi >= this

    # Prior tempering (v2.22.1): Scales priors by 1/K per shard
    prior_tempering: true

    backend_config:
      name: "auto"
      enable_checkpoints: true
      checkpoint_frequency: 1
      checkpoint_dir: "./checkpoints/cmc"
      keep_last_checkpoints: 3
      resume_from_checkpoint: true

    sharding:
      strategy: "random"
      num_shards: "auto"
      max_points_per_shard: "auto" # Dynamic: 12K-21K after angle scaling (v2.20.0)
      min_points_per_shard: 10000 # CRITICAL: Prevents data-starved shards
      seed_base: 0
      min_points_per_param: 1500 # Minimum points per parameter per shard

    per_shard_timeout: 3600
    heartbeat_timeout: 600

    combination:
      method: "robust_consensus_mc" # MAD-based outlier detection (default since v2.22.1)
      validate_results: true
      min_success_rate: 0.80 # Lower for complex 7-param model
      min_success_rate_warning: 0.70

    per_shard_mcmc:
      num_warmup: 500
      num_samples: 1500
      num_chains: 4
      target_accept_prob: 0.85

      # -----------------------------------------------------------------------
      # ADAPTIVE SAMPLING (v2.22.0 / Feb 2026)
      # -----------------------------------------------------------------------
      # Automatically reduces warmup/samples for small datasets to decrease
      # NUTS overhead. Profiling showed 1310s for 50 points with defaults;
      # adaptive scaling reduces this by 60-80%.
      #
      # Scaling: shard_size / 10000 → scale factor (capped at 1.0)
      #   50 pts → 140 warmup, 350 samples (75% reduction)
      #   5000 pts → 250 warmup, 750 samples (50% reduction)
      #   50000+ pts → full defaults (no reduction)
      adaptive_sampling: true # Enable adaptive sample count
      max_tree_depth: 10 # NUTS tree depth (max 2^depth leapfrog steps)
      min_warmup: 100 # Minimum warmup even for tiny datasets
      min_samples: 200 # Minimum samples for statistical validity

      # -----------------------------------------------------------------------
      # JAX PROFILING (v2.22.0 / Feb 2026)
      # -----------------------------------------------------------------------
      # py-spy only profiles Python code; XLA runs native code invisible to it.
      # Enable JAX profiling to capture XLA-level performance data.
      # View with: tensorboard --logdir=./profiles/jax
      enable_jax_profiling: false # Enable jax.profiler tracing
      jax_profile_dir: ./profiles/jax # Output directory for JAX traces

    validation:
      strict_mode: false # Relaxed for complex 7-param model
      min_per_shard_ess: 100.0
      max_per_shard_rhat: 1.2
      max_between_shard_kl: 0.5
      min_success_rate: 0.80

      # NLSQ warm-start & quality control (v2.20.0)
      # NOTE: CLI automatically runs NLSQ before CMC (homodyne --method cmc)
      # Disable with: --no-nlsq-warmstart (NOT recommended for laminar_flow)
      max_divergence_rate: 0.10 # Filter shards with >10% divergences
      require_nlsq_warmstart: false # Set true to enforce in API calls

      # NLSQ-informed priors (v2.22.1)
      use_nlsq_informed_priors: true
      nlsq_prior_width_factor: 2.0
      max_parameter_cv: 1.0 # Heterogeneity threshold
      heterogeneity_abort: false # Abort with guidance if CV exceeded

    # -------------------------------------------------------------------------
    # REPARAMETERIZATION (v2.21.0 / Jan 2026)
    # -------------------------------------------------------------------------
    # Transforms sampling space to break D0/D_offset degeneracy and improve
    # NUTS sampling for gamma_dot_t0.
    #
    # D_total Reparameterization:
    #   Sample D_total = D0 + D_offset instead of D0 directly.
    #   Breaks the linear degeneracy between D0 and D_offset.
    #
    # Log-Gamma Reparameterization (CRITICAL for laminar_flow):
    #   Sample log(gamma_dot_t0) instead of gamma_dot_t0 directly.
    #   Essential when shear rates span orders of magnitude (1e-6 to 0.5 s⁻¹).
    #
    # Bimodal Detection:
    #   Post-sampling GMM analysis to detect bimodal posteriors.
    #   Bimodality may indicate model identifiability issues.
    #
    reparameterization:
      enable_d_total: true # Sample D_total = D0 + D_offset
      enable_log_gamma: true # Sample log(gamma_dot_t0) - IMPORTANT
      bimodal_min_weight:
        0.2 # Minimum GMM component weight
        # CONSTRAINT: (0, 0.5]
      bimodal_min_separation:
        0.5 # Minimum relative separation
        # CONSTRAINT: (0, 2.0]

# ==============================================================================
# NOISE ESTIMATION (Optional)
# ==============================================================================
noise_estimation:
  enabled: false
  model: "per_angle"

  adam_config:
    learning_rate: 0.01
    max_epochs: 500
    convergence_threshold: 1.0e-6
    early_stopping: true

  posterior_samples: 1200

  validation:
    check_convergence: true
    reasonable_range: [1.0e-4, 1.0]
    warn_outliers: true

  per_angle:
    min_angles_required: 2
    validate_coverage: true

# ==============================================================================
# PERFORMANCE
# ==============================================================================
performance:
  strategy_override: null
  memory_limit_gb: null
  enable_progress: true

  memory_optimization:
    enabled: true
    max_memory_usage_gb: 6.0
    chunk_size: 8000
    enable_caching: true
    cache_strategy: "adaptive"

  computation:
    enable_jit: true
    cpu_threads: "auto"
    vectorization_level: "high"

# ==============================================================================
# LOGGING
# ==============================================================================
logging:
  enabled: true
  level: "INFO"

  console:
    enabled: true
    level: "INFO"
    format: "detailed"
    colors: true
    show_progress: true

  file:
    enabled: false
    level: "DEBUG"
    path: "./logs/"
    filename: "homodyne_laminar_flow.log"
    max_size_mb: 10
    backup_count: 5

  modules:
    "homodyne.data.phi_filtering": "INFO"
    "homodyne.data.xpcs_loader": "INFO"
    "homodyne.optimization.nlsq_wrapper": "INFO"
    "jax._src": "WARNING"

# ==============================================================================
# QUALITY CONTROL (Optional)
# ==============================================================================
quality_control:
  enabled: false

  angle_quality:
    validate_angle_coverage: true
    min_angles_per_range: 1
    check_angle_distribution: true

  multi_angle_validation:
    check_correlation_consistency: true
    validate_angle_dependencies: true
    detect_anomalous_angles: true

# ==============================================================================
# PLOTTING
# ==============================================================================
plotting:
  save_plots: true
  show_plots: false
  format: "png"
  dpi: 300
  style: "publication"

  preview_mode: false
  fit_surface: "solver"

  color_scale:
    mode: "legacy"
    pin_legacy_range: true
    percentile_min: 1.0
    percentile_max: 99.0
    fixed_min: 1.0
    fixed_max: 1.5

  datashader:
    canvas_width: 1200
    canvas_height: 1200

  matplotlib:
    interpolation: "bilinear"
    use_tight_layout: true
    savefig_kwargs:
      bbox_inches: "tight"
      pad_inches: 0.1

  correlation_function: true
  fit_quality: true
  parameter_distributions: true
  residual_analysis: true
  angle_coverage: true
  angle_correlation: true

# ==============================================================================
# OUTPUT
# ==============================================================================
output:
  directory: "./results"
  base_directory: "./homodyne_results/"

  formats:
    hdf5: true
    json: true
    csv: true

  create_subdirs: true
  timestamp_dirs: false
  compress_hdf5: true
  compression_level: 6

# ==============================================================================
# VALIDATION (Optional)
# ==============================================================================
validation:
  strict_mode: false
  check_file_existence: true
  validate_parameter_ranges: true
  check_mode_compatibility: true

  angle_validation:
    require_multiple_angles: false
    min_angle_count: 1
    validate_angle_ranges: true

# ==============================================================================
# LAMINAR FLOW - QUICK REFERENCE
# ==============================================================================
#
# WORKFLOW:
# ---------
# 1. Update experimental_data paths
# 2. Adjust phi_filtering for parallel (0°) + perpendicular (90°)
# 3. Run NLSQ: homodyne --config this_file.yaml --method nlsq
# 4. Copy NLSQ results to initial_parameters.values
# 5. Run MCMC: homodyne --config this_file.yaml --method mcmc
#
# GRADIENT IMBALANCE FIX:
# -----------------------
# Shear parameters can have 1000-10000× larger gradients than diffusion params.
# SYMPTOM: Early convergence, missing C2 oscillations, flat shear parameters
# SOLUTION: Enable CMA-ES (nlsq.cmaes.enable: true) for scale ratio > 1000
#           OR compute x_scale_map: python scripts/diagnose_gradients.py
#
# PARAMETER COUNTING:
# -------------------
# Total = 7 physical + 2 × N_angles
# Example: 3 angles → 13 parameters
#
# PHYSICAL INTERPRETATION:
# ------------------------
# D₀: Diffusion magnitude (100-10000 Å²/s, higher under shear)
# α: Anomalous exponent (shear often causes α > 0)
# D_offset: Baseline diffusion (-100 to 100 Å²/s)
# γ̇₀: Shear rate (1e-6 to 0.5 s⁻¹)
# β: Shear evolution (0=constant, ≠0=time-dependent)
# γ̇_offset: Baseline shear (-0.1 to 0.1 s⁻¹)
# φ₀: Flow direction angle (-10° to 10°)
#
# VALIDATION:
# -----------
# homodyne-config --validate this_file.yaml
#
# ==============================================================================
# END OF LAMINAR FLOW TEMPLATE
# ==============================================================================
