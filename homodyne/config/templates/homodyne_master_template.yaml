# ==============================================================================
# HOMODYNE MASTER CONFIGURATION TEMPLATE
# ==============================================================================
# Comprehensive reference template containing ALL configuration parameters
# for all analysis modes, optimization methods, and advanced features.
#
# This template includes EVERYTHING supported by homodyne v2.4.0.
# Use homodyne_static.yaml or homodyne_laminar_flow.yaml for simpler starts.
#
# VERSION: 2.4.1
# UPDATED: 2025-11-13
# ==============================================================================

# ==============================================================================
# METADATA (Required)
# ==============================================================================
# Template metadata describing analysis configuration
metadata:
  config_version: "2.4.1" # Configuration file format version
  description: "Master template - comprehensive reference (v3.0: CPU-only, per-angle scaling mandatory, CMC-only MCMC)"
  analysis_mode: "laminar_flow" # Options: "static" | "laminar_flow"
  parameter_count: 7 # 3 for static, 7 for laminar_flow

  # Physics model description
  physics_model: "D(t,φ) = D₀·t^α + D_offset + shear_effects(γ̇(t),φ)"
  shear_model: "γ̇(t) = γ̇₀·t^β + γ̇_offset" # For laminar_flow mode only

  # Integration and correction methods
  integration_method: "discrete_numerical" # Discrete numerical integration for stability
  diagonal_correction: "mandatory" # Diagonal correction for consistency

  # Template classification
  recommended_use: "Comprehensive parameter reference for all analysis types"
  template_type: "reference" # Options: "reference" | "production_ready" | "example"
  complexity: "comprehensive" # All features documented

  # Key features of this configuration
  key_features:
    - "Complete parameter documentation for static and laminar_flow modes"
    - "Gradient imbalance fix (v2.4.1) - x_scale_map for laminar flow"
    - "Gradient diagnostics tool - automatic detection and fixing"
    - "CPU-only architecture (v2.3.0) with JAX 0.8.0 - GPU support removed"
    - "Per-angle scaling mandatory (v2.4.0) - legacy scalar mode removed"
    - "Automatic NUTS/CMC selection in MCMC (v2.1.0) - dual criteria logic"
    - "All optimization methods (NLSQ, MCMC with auto NUTS/CMC, Streaming)"
    - "Angle-stratified chunking (v2.2.0) - fixes silent NLSQ failures"
    - "Advanced phi angle filtering with quality control"
    - "Shear parameter transforms for improved conditioning"
    - "Comprehensive diagnostics and validation"
    - "Noise estimation with multiple models"
    - "HPC CPU optimization for multi-core systems"
    - "Comprehensive troubleshooting guidance and diagnostic tools"

  # Optional: Generation metadata (filled by homodyne-config)
  generated_at: null # ISO timestamp when config generated
  generated_by: null # Tool used to generate config

# ==============================================================================
# ANALYSIS MODE (Required)
# ==============================================================================
# Primary analysis mode selection
analysis_mode: "laminar_flow" # Options: "static" | "laminar_flow"

# ==============================================================================
# ANALYZER PARAMETERS (Required)
# ==============================================================================
# Core physical and instrumental parameters for analysis
analyzer_parameters:
  # Time resolution
  dt: 0.1 # Time step between correlation measurements [seconds]

  # Frame range for analysis
  start_frame: 1000 # Starting frame number (1-indexed)
  end_frame: 2000 # Ending frame number (inclusive)

  # Scattering parameters
  scattering:
    wavevector_q: 0.0054 # Wave vector magnitude [Å⁻¹] - sample dependent

  # Geometry parameters (instrumental setup)
  geometry:
    stator_rotor_gap: 2000000 # Gap between stator and rotor [Å] (200 microns = 2000000 Å)

# ==============================================================================
# ANALYSIS SETTINGS (Required)
# ==============================================================================
# Analysis mode-specific settings and model description
analysis_settings:
  static_mode: false # true for static analysis, false for laminar_flow

  # Model description for documentation
  model_description:
    type: "nonequilibrium_laminar_flow" # Options: "static_diffusion" | "nonequilibrium_laminar_flow"
    parameters: 7 # 3 for static, 7 for laminar_flow
    physics: "Time-dependent diffusion and shear with flow direction" # Physics description

# ==============================================================================
# EXPERIMENTAL DATA (Required)
# ==============================================================================
# Paths to experimental data files and caching configuration
experimental_data:
  # Primary data file (HDF5 format)
  file_path: "./data/sample/experiment.hdf" # Preferred: Direct path to HDF5 file

  # Legacy format (data_folder_path + data_file_name)
  data_folder_path: "./data/sample/" # Folder containing data file
  data_file_name: "experiment.hdf" # HDF5 data file name

  # Phi angles configuration
  phi_angles_path: "./data/sample/" # Folder containing phi angles list
  phi_angles_file: "phi_angles_list.txt" # Text file with phi angles (one per line)

  # Caching for performance (saves processed C2 data)
  cache_file_path: "./data/sample/" # Cache directory
  cache_filename_template: "cached_c2_q{wavevector_q:.4f}_frames_{start_frame}_{end_frame}.npz" # Template with placeholders
  cache_compression: true # Enable compression for cache files

  # Data format specifications
  data_type: "float64" # Data type for arrays
  file_format: "HDF5" # File format (currently only HDF5 supported)
  exchange_key: "exchange" # HDF5 group key for exchange data

# ==============================================================================
# PHI ANGLE FILTERING
# ==============================================================================
# Advanced phi angle filtering for optimal scattering analysis
phi_filtering:
  enabled: true # Enable angle filtering to reduce parameter count

  # Target angle ranges (all angles normalized to [-180°, 180°])
  # Angles are checked with wrap-aware logic (e.g., [170°, -170°] works correctly)
  target_ranges:
    # Range 1: Near 0° (parallel to flow for laminar_flow, or parallel to anisotropy axis)
    - min_angle: -10.0 # Minimum angle [degrees]
      max_angle: 10.0 # Maximum angle [degrees]
      description: "Parallel to flow/primary axis"

    # Range 2: Near 90° (perpendicular to flow)
    - min_angle: 85.0
      max_angle: 95.0
      description: "Perpendicular to flow"

    # Range 3: Near 180° (antiparallel)
    # - min_angle: 170.0
    #   max_angle: 190.0
    #   description: "Antiparallel to primary axis"

    # Range 4: Near -90° (perpendicular, opposite side)
    # - min_angle: -95.0
    #   max_angle: -85.0
    #   description: "Perpendicular (opposite side)"

  # Fallback behavior
  fallback_to_all_angles: true # Use all angles if no angles match target ranges

  # Filtering algorithm
  algorithm: "range_based" # Algorithm type (currently only range_based)
  tolerance: 3.0 # Angular tolerance [degrees] for range matching

  # Quality control for angle selection
  quality_control:
    min_angles_required: 1 # Minimum number of angles required for analysis
    max_angle_spread: 36.0 # Maximum spread within a single range [degrees]
    validate_coverage: true # Validate that angles adequately cover target ranges
    require_orthogonal_angles: true # Require angles in perpendicular directions (for laminar_flow)

# ==============================================================================
# INITIAL PARAMETERS (Required)
# ==============================================================================
# Starting parameter values for optimization
#
# PARAMETER COUNT:
# ----------------
# Total parameters = Physical parameters + Scaling parameters per angle
#
# **PER-ANGLE SCALING MANDATORY (v2.4.0)**:
#   - Legacy scalar contrast/offset mode REMOVED
#   - Each scattering angle has unique optical/detector properties
#   - Passing per_angle_scaling=False will raise ValueError
#
# Static (3 physical):
#   Physical: [D₀, α, D_offset]
#   Per-angle scaling: [contrast, offset] × N angles
#   Total: 3 + 2N (e.g., 3 angles → 9 parameters)
#
# Laminar Flow (7 physical):
#   Physical: [D₀, α, D_offset, γ̇₀, β, γ̇_offset, φ₀]
#   Per-angle scaling: [contrast, offset] × N angles
#   Total: 7 + 2N (e.g., 3 angles → 13 parameters)
#
initial_parameters:
  # Parameter names to optimize
  # For static mode, use: ["D0", "alpha", "D_offset"]
  # For laminar_flow mode, use all 7 parameters below
  parameter_names:
    - D0 # Diffusion coefficient prefactor
    - alpha # Anomalous diffusion exponent
    - D_offset # Baseline diffusion
    - gamma_dot_t0 # Initial shear rate at t=0
    - beta # Shear rate exponent
    - gamma_dot_t_offset # Baseline shear rate offset
    - phi0 # Initial angle offset

  # Optional: Initial values (if not provided, uses mid-point of bounds)
  values: null # List of floats matching parameter_names order

  # Per-angle scaling initialization (v2.4.0 mandatory)
  # IMPORTANT: Initialize from NLSQ results or estimate from data to prevent MCMC convergence failures
  # For NLSQ→MCMC workflow: Run NLSQ first, copy contrast/offset from results
  # For data estimation: contrast ≈ (C2_max - C2_min), offset ≈ C2_min
  per_angle_scaling:
    contrast: null # List of N floats (one per angle)
    offset: null # List of N floats (one per angle)
    # Example for 3 angles: contrast: [0.05, 0.06, 0.05], offset: [1.0, 0.99, 1.01]
    # Example for 1 angle:  contrast: [0.06], offset: [0.99]
    # Typical ranges: contrast [0.01-0.2], offset [0.9-1.1] for XPCS data

  # Optional: Units for documentation
  units: # Parameter units (for reference)
    - "Å²/s" # D0
    - "dimensionless" # alpha
    - "Å²/s" # D_offset
    - "s⁻¹" # gamma_dot_t0
    - "dimensionless" # beta
    - "s⁻¹" # gamma_dot_t_offset
    - "degrees" # phi0

  # Optional: Optimize only a subset of parameters (rest held at initial values)
  active_parameters: null # List of parameter names to actively optimize
  # Example: ["D0", "alpha", "gamma_dot_t0"]

  # Optional: Fix specific parameters at given values
  fixed_parameters: null # Dict mapping parameter names to fixed values
  # Example: {"D_offset": 10.0, "beta": 0.0}

# ==============================================================================
# PARAMETER SPACE (Required)
# ==============================================================================
# Parameter bounds and constraints
parameter_space:
  model: "laminar_flow" # Options: "static" | "laminar_flow"

  bounds:
    # -------------------------------------------------------------------------
    # DIFFUSION PARAMETERS (Required for all models)
    # -------------------------------------------------------------------------
    - name: D0
      min: 100.0 # Minimum diffusion coefficient [Å²/s]
      max: 1e5 # Maximum diffusion coefficient [Å²/s]
      type: TruncatedNormal # Bound type for priors
      prior_mu: 1000.0 # Prior mean (for Bayesian methods)
      prior_sigma: 1000.0 # Prior std dev (for Bayesian methods)
      unit: "Å²/s"
      # Physical meaning: Controls magnitude of diffusion in D(t) = D₀·t^α + D_offset
      # Typical range: 100-10000 for colloidal systems

    - name: alpha
      min: -2.0 # ✅ FIXED: Physically realistic minimum (was -10.0)
      max: 2.0 # ✅ FIXED: Physically realistic maximum (was 10.0)
      type: TruncatedNormal # ✅ FIXED: Changed from Normal to enforce bounds
      prior_mu: -1.2 # Prior mean
      prior_sigma: 0.3 # Prior std dev
      # ✅ Bounds tightened: [-10,10] caused numerical underflow (alpha=-4.96 → theory≈0)
      unit: "dimensionless"
      # Physical meaning: Anomalous diffusion exponent
      # 0 = normal diffusion, <0 = subdiffusion, >0 = superdiffusion
      # Typical range: -2 to 2 for most systems

    - name: D_offset
      min: -100000.0 # Minimum baseline diffusion [Å²/s]
      max: 100000.0 # Maximum baseline diffusion [Å²/s]
      type: TruncatedNormal # ✅ FIXED: Changed from Normal to enforce bounds
      prior_mu: 0.0 # Prior mean
      prior_sigma: 150.0 # Prior std dev
      unit: "Å²/s"
      # Physical meaning: Constant diffusion contribution (can be negative)
      # Typical range: -100 to 100 for most systems

    # -------------------------------------------------------------------------
    # FLOW PARAMETERS (Required for laminar_flow mode only)
    # -------------------------------------------------------------------------
    - name: gamma_dot_t0 # Initial shear rate at t=0
      min: 1e-6 # Minimum initial shear rate [s⁻¹]
      max: 0.5 # Maximum initial shear rate [s⁻¹]
      type: TruncatedNormal
      prior_mu: 0.01 # Prior mean
      prior_sigma: 0.1 # Prior std dev
      unit: "s⁻¹"
      # Physical meaning: Shear rate prefactor in γ̇(t) = γ̇₀·t^β + γ̇_offset
      # Adjust based on experimental shear rates

    - name: beta
      min: -2.0 # Minimum shear exponent
      max: 2.0 # Maximum shear exponent
      type: TruncatedNormal # ✅ FIXED: Changed from Normal to enforce bounds
      prior_mu: 0.0 # Prior mean
      prior_sigma: 0.5 # Prior std dev
      unit: "dimensionless"
      # Physical meaning: Shear rate time evolution exponent
      # 0 = constant shear, >0 = increasing shear, <0 = decreasing shear

    - name: gamma_dot_t_offset # Baseline shear rate offset
      min: -0.1 # Minimum baseline shear [s⁻¹]
      max: 0.1 # Maximum baseline shear [s⁻¹]
      type: TruncatedNormal # ✅ FIXED: Changed from Normal to enforce bounds
      prior_mu: 0.0 # Prior mean
      prior_sigma: 0.02 # Prior std dev
      unit: "s⁻¹"
      # Physical meaning: Constant shear contribution
      # Typically small or zero

    - name: phi0 # Initial angle offset
      min: -180.0 # Minimum initial angle [degrees]
      max: 180.0 # Maximum initial angle [degrees]
      type: TruncatedNormal # ✅ FIXED: Changed from Normal to enforce bounds
      prior_mu: 0.0 # Prior mean
      prior_sigma: 30.0 # Prior std dev
      unit: "degrees"
      # Physical meaning: Angle between flow direction and scattering vector
      # Automatically normalized to [-180°, 180°]

  # Optional: Prior distributions for Bayesian methods
  priors: null # Advanced prior specifications (rarely needed)

# ==============================================================================
# OPTIMIZATION METHODS
# ==============================================================================
# Optimization method selection and configuration
optimization:
  method:
    "nlsq" # Options: "nlsq" | "mcmc"
    # Note: NUTS/CMC is auto-selected within MCMC based on dual criteria

  # ---------------------------------------------------------------------------
  # NLSQ - Trust-Region Nonlinear Least Squares (Primary Method)
  # ---------------------------------------------------------------------------
  # Fast, deterministic optimization using Levenberg-Marquardt algorithm
  # CPU-optimized with JAX 0.8.0 (v2.3.0+), JIT-compiled for performance
  # Automatic strategy selection based on dataset size:
  #   < 1M points     → STANDARD (curve_fit)
  #   1M-10M points   → LARGE (curve_fit_large)
  #   10M-100M points → CHUNKED (curve_fit_large with progress)
  #   > 100M points   → STREAMING (unlimited data with checkpointing)
  nlsq:
    max_iterations: 100 # Maximum optimization iterations
    tolerance: 1e-8 # Convergence tolerance
    trust_region_scale: 1.0 # Trust region scaling factor (0.1-10.0)
    verbose: false # Print iteration details
    loss: "soft_l1" # Loss function: "linear" | "soft_l1" | "huber" | "cauchy" | "arctan"

    # -------------------------------------------------------------------------
    # PARAMETER-SPECIFIC SCALING (CRITICAL FOR LAMINAR FLOW)
    # -------------------------------------------------------------------------
    # Fixes gradient imbalance where shear parameters can have gradients
    # 100-10,000× larger than diffusion parameters, causing:
    #   - Premature convergence (optimizer stops while shear params need work)
    #   - Missing oscillations in fitted c2 heatmaps (key homodyne feature!)
    #   - Poor fit quality despite low chi-squared values
    #
    # GRADIENT IMBALANCE BACKGROUND:
    # -------------------------------
    # In laminar flow systems, shear parameters (gamma_dot_t0, beta, gamma_dot_t_offset)
    # have drastically larger gradients than diffusion parameters (D0, alpha, D_offset).
    # This causes the optimizer to take huge steps in shear space (overshooting) and
    # tiny steps in diffusion space (frozen), leading to premature termination when
    # trust region limits are reached, even though the cost function still has steep
    # descent directions in the shear parameter subspace.
    #
    # SOLUTION: Apply parameter-specific x_scale values inversely proportional to
    # gradient magnitudes to normalize optimization steps across all parameters.
    #
    # WHEN TO USE:
    # ------------
    # MANDATORY for laminar_flow mode (shear parameters always have large gradients)
    # OPTIONAL for static mode (gradient imbalance less severe)
    #
    # HOW TO COMPUTE OPTIMAL VALUES:
    # -------------------------------
    # Step 1: Run initial NLSQ optimization without x_scale_map
    #   homodyne --config config.yaml --method nlsq
    #
    # Step 2: Diagnose gradient imbalance using diagnostic tool
    #   python scripts/diagnose_gradients.py --results-dir ./homodyne_results/nlsq --output x_scale_fix.yaml
    #
    # Step 3: Apply recommended x_scale_map to config and re-run
    #   (merge x_scale_fix.yaml values into this section)
    #
    # Step 4: Verify improved fit quality
    #   - Check fitted c2 heatmaps show decay oscillations
    #   - Verify chi-squared improvement (typically 10-50% reduction)
    #   - Confirm more iterations completed (proper convergence, not premature stop)
    #
    x_scale_map: # Per-parameter scaling (dict or null)
      # LAMINAR FLOW MODE: Apply these values to fix gradient imbalance
      # (derived from C020 dataset analysis, Nov 2025)
      D0: 1.20 # Baseline diffusion (1.0× scaling)
      alpha: 0.000761 # Anomalous exponent (1,313× reduction)
      D_offset: 1.13 # Baseline diffusion offset (1.0× scaling)
      gamma_dot_t0: 0.00000371 # Shear rate (269,251× reduction)
      beta: 0.000314 # Shear exponent (3,188× reduction)
      gamma_dot_t_offset: 0.0000000930 # Shear offset (10,755,776× reduction!)
      phi0: 0.739 # Flow angle (1.0× scaling)
    # STATIC MODE: Uncomment and adjust if gradient diagnostics shows imbalance
    # x_scale_map:
    #   D0: 1.0
    #   alpha: 0.01                            # If alpha gradient 100× larger
    #   D_offset: 1.0
    # Or set to null for uniform scaling:
    # x_scale_map: null

    # -------------------------------------------------------------------------
    # SHEAR TRANSFORM CONFIGURATION (OPTIONAL)
    # -------------------------------------------------------------------------
    # Applies coordinate transformations to shear parameters to improve conditioning
    # Helps normalize parameter magnitudes for better optimization
    # Recommended for systems with extreme shear rate values or time-dependent shear
    shear_transforms:
      enabled: false # Enable shear parameter transforms
      gamma_dot_t0_ref:
        0.01 # Reference shear rate [s⁻¹]
        # Shifts beta constraint to reduce correlation
      beta_ref:
        0.0 # Reference beta exponent
        # Centers beta around physically meaningful value
      # Technical details:
      #   Forward: beta_transformed = beta - beta_ref
      #           gamma_dot_t0_transformed = gamma_dot_t0 - gamma_dot_t0_ref * t^beta_ref
      #   Inverse: Automatically applied to results
      # Use when: shear parameters hit bounds or show high correlation

    # -------------------------------------------------------------------------
    # DIAGNOSTICS AND VALIDATION (RECOMMENDED)
    # -------------------------------------------------------------------------
    # Enable detailed diagnostics for gradient analysis and convergence monitoring
    # Helps detect issues early and provides insights for parameter scaling
    diagnostics:
      enabled: false # Enable NLSQ diagnostics
      sample_size:
        2048 # Sample size for Jacobian diagnostics
        # Larger = more accurate but slower
      check_gradients:
        true # Verify gradient computations via finite differences
        # Detects autodiff issues, minimal overhead
      log_jacobian_norms:
        false # Log parameter sensitivity (Jacobian column norms)
        # Reveals which parameters have large gradients
        # Set to true if experiencing convergence issues

  # ---------------------------------------------------------------------------
  # STRATIFICATION - Angle-Stratified Chunking (v2.2+)
  # ---------------------------------------------------------------------------
  # Fixes per-angle parameter compatibility with NLSQ chunking for large datasets
  # Automatically reorganizes data to ensure all chunks contain all phi angles
  # Prevents silent optimization failures (0 iterations, zero gradients)
  # CRITICAL for datasets >100k points with per-angle scaling
  stratification:
    enabled:
      "auto" # Options: "auto" | true | false
      # "auto" activates when: per_angle_scaling=True AND n_points>=100k
    target_chunk_size:
      100000 # Target size for stratified chunks [points]
      # Should match NLSQ's internal chunk size
    max_imbalance_ratio:
      5.0 # Maximum angle imbalance ratio before fallback
      # Fallback to sequential if max_count/min_count > threshold
    force_sequential_fallback:
      false # Force sequential per-angle optimization
      # Useful for highly imbalanced angle distributions
    check_memory_safety:
      true # Check available memory before stratification
      # Warns if peak memory > 70% of available
    use_index_based:
      false # Use zero-copy index-based stratification
      # Reduces memory overhead from 2x to ~1%
      # Recommended for very large datasets (>10M points)
    collect_diagnostics:
      false # Collect detailed stratification diagnostics
      # Performance metrics, chunk balance, angle coverage
      # Minimal overhead (~0.01s)
    log_diagnostics:
      false # Log diagnostic report to console
      # Requires collect_diagnostics=true
      # Useful for troubleshooting and validation

  # Performance Impact:
  # - Time overhead: <1% (0.15s for 3M points)
  # - Memory overhead: 2x peak (temporary) or ~1% (index-based)
  # - Diagnostics overhead: <0.1% (0.01s for 3M points)
  # - Fixes: Silent failures with per-angle scaling on large datasets

  # ---------------------------------------------------------------------------
  # SEQUENTIAL - Sequential Per-Angle Optimization (v2.2+)
  # ---------------------------------------------------------------------------
  # Fallback strategy when stratification cannot be applied
  # Optimizes each phi angle independently and combines results
  # Used when: angle imbalance > threshold OR force_sequential_fallback=true
  sequential:
    min_success_rate:
      0.5 # Minimum fraction of angles that must converge
      # Optimization fails if fewer angles converge
    weighting:
      "inverse_variance" # Result combination method
      # Options: "inverse_variance" | "uniform" | "n_points"
      # "inverse_variance" provides optimal statistical weighting

  # Usage Notes:
  # - Automatically activated when: imbalance_ratio > max_imbalance_ratio
  # - Can be forced via: optimization.stratification.force_sequential_fallback=true
  # - Uses scipy.optimize.least_squares per angle (CPU only)
  # - Combines results using weighted averaging

  # ---------------------------------------------------------------------------
  # MCMC - Markov Chain Monte Carlo (Uncertainty Quantification)
  # ---------------------------------------------------------------------------
  # Provides full posterior distributions and uncertainty estimates
  # CMC-only posterior sampling with per-shard NumPyro/BlackJAX NUTS
  mcmc:
    backend: "numpyro" # Options: "numpyro" | "blackjax"
    num_warmup: 2000 # NUTS warmup/adaptation samples
    num_samples: 5000 # Posterior samples per chain
    num_chains: 4 # Parallel chains
    progress_bar: true # Show sampling progress
    target_accept_prob: 0.90 # NUTS target acceptance probability
    max_tree_depth: 12 # Maximum NUTS tree depth
    dense_mass_matrix: true # Full covariance mass matrix
    sharding:
      num_shards: auto # auto = choose based on hardware
      seed_base: 0 # Base RNG seed for shard seeds
    initial_values:
      phi: {} # Optional per-phi overrides: angle_deg: {contrast, offset}
      percentile_fallback:
        contrast_low_pct: 5
        contrast_high_pct: 95
        offset_pct: 50

  # ---------------------------------------------------------------------------
  # STREAMING - For Large Datasets (> 100M points)
  # ---------------------------------------------------------------------------
  # Constant memory footprint with checkpoint/resume capability
  streaming:
    enable_checkpoints: true # Enable HDF5 checkpoint save/resume
    checkpoint_dir: "./checkpoints" # Directory for checkpoint files
    checkpoint_frequency: 10 # Save checkpoint every N batches
    resume_from_checkpoint: true # Auto-detect and resume from latest checkpoint
    keep_last_checkpoints: 3 # Number of recent checkpoints to keep (older deleted)

    # Fault tolerance and error recovery
    enable_fault_tolerance: true # Enable numerical validation and recovery
    max_retries_per_batch: 2 # Maximum retry attempts per failed batch
    min_success_rate: 0.5 # Minimum batch success rate (0.0-1.0) before failing

    # Batch processing
    batch_size: null # Batch size in points (null = auto-detect based on memory)
    adaptive_batching: true # Dynamically adjust batch size based on performance

  # ---------------------------------------------------------------------------
  # CMC Sharding/Combination
  # ---------------------------------------------------------------------------
  cmc:
    backend: "jax" # CMC coordinator backend (CPU-only)
    diagonal_correction: true # Apply diagonal correction to correlation matrix

    # Data sharding configuration
    sharding:
      strategy: "stratified" # Options: "stratified" | "random" | "contiguous"
      num_shards: "auto" # Number of shards (int or "auto" for automatic)
      max_points_per_shard: "auto" # Maximum points per shard (int or "auto")

    # Backend configuration for parallel execution
    backend_config:
      name: "auto" # Options: "auto" | "pjit" | "multiprocessing" | "pbs" | "slurm"
      enable_checkpoints: true # Enable checkpoint functionality
      checkpoint_frequency: 1 # Save checkpoint every N shards
      checkpoint_dir: "./cmc_checkpoints" # Directory for CMC checkpoint files
      keep_last_checkpoints: 3 # Number of recent checkpoints to keep
      resume_from_checkpoint: true # Auto-resume from latest checkpoint

    # Subposterior combination method
    combination:
      method: "weighted_gaussian" # Options: "weighted_gaussian" | "simple_average" | "auto"
      validate_results: true # Validate combined posterior quality
      min_success_rate: 0.8 # Minimum fraction of shards that must converge (0.0-1.0)

    # Per-shard MCMC configuration
    per_shard_mcmc:
      num_warmup: 500 # Warmup steps per shard
      num_samples: 1000 # Samples per shard
      num_chains: 2 # Chains per shard
      subsample_size: "auto" # Subsample size (int or "auto" for automatic subsampling)

    # Convergence validation
    validation:
      strict_mode: false # Fail if validation criteria not met
      min_per_shard_ess: 100 # Minimum effective sample size per parameter per shard
      max_per_shard_rhat: 1.2 # Maximum R-hat per parameter per shard
      max_between_shard_kl: 0.5 # Maximum KL divergence between shard posteriors
      min_success_rate: 0.8 # Minimum fraction of shards that must converge

# ==============================================================================
# NOISE ESTIMATION (Optional)
# ==============================================================================
# Automatic noise level estimation using hybrid NumPyro approach
# Estimates per-angle or global noise variance to improve fit quality
noise_estimation:
  enabled: false # Enable automatic noise estimation
  model: "per_angle" # Options: "per_angle" | "global"

  # Adam optimization settings for noise parameter estimation
  adam_config:
    learning_rate: 0.01 # Adam learning rate
    max_epochs: 500 # Maximum optimization epochs
    convergence_threshold: 1e-6 # Convergence threshold for loss
    early_stopping: true # Enable early stopping for efficiency

  # Posterior sampling for uncertainty quantification
  posterior_samples: 1200 # Number of posterior samples for noise uncertainty

  # Quality control for noise estimation
  validation:
    check_convergence: true # Verify optimization convergence
    reasonable_range: [1e-4, 1.0] # Expected noise range (bounds for sanity check)
    warn_outliers: true # Warn about unusual noise estimates

  # Per-angle model settings
  per_angle:
    min_angles_required: 2 # Minimum angles needed for per-angle estimation
    validate_coverage: true # Ensure proper angle coverage

# ==============================================================================
# PERFORMANCE OPTIMIZATION
# ==============================================================================
# Performance and memory management settings
performance:
  # Strategy override (null = automatic selection based on dataset size)
  strategy_override: null # Options: null | "standard" | "large" | "chunked" | "streaming"

  # Memory management
  memory_limit_gb: null # Custom memory limit in GB (null = auto-detect)
  enable_progress: true # Show progress bars during optimization

  # Memory optimization settings
  memory_optimization:
    enabled: true # Enable memory optimization
    max_memory_usage_gb: 6.0 # Maximum memory usage [GB]
    chunk_size: 8000 # Data chunk size for processing
    enable_caching: true # Enable intelligent caching
    cache_strategy: "adaptive" # Options: "adaptive" | "aggressive" | "conservative"

  # Computation settings
  computation:
    enable_jit: true # Enable JAX JIT compilation
    cpu_threads: "auto" # Number of CPU threads (int or "auto")
    vectorization_level: "high" # Options: "low" | "medium" | "high"
    # Note: GPU support removed in v2.3.0 (use v2.2.x for GPU)

# ==============================================================================
# LOGGING
# ==============================================================================
# Logging configuration for analysis monitoring
logging:
  enabled: true # Enable logging
  level: "INFO" # Options: "DEBUG" | "INFO" | "WARNING" | "ERROR"

  # Console logging
  console:
    enabled: true # Log to console
    level: "INFO" # Console log level
    format: "detailed" # Options: "simple" | "detailed"
    colors: true # Enable colored output
    show_progress: true # Show progress indicators

  # File logging
  file:
    enabled: false # Log to file
    level: "DEBUG" # File log level
    path: "./logs/" # Log directory
    filename: "homodyne_analysis.log" # Log file name
    max_size_mb: 10 # Maximum log file size before rotation
    backup_count: 5 # Number of backup log files to keep

  # Module-specific logging levels
  modules:
    "homodyne.data.phi_filtering": "INFO"
    "homodyne.data.xpcs_loader": "INFO"
    "homodyne.optimization.nlsq_wrapper": "INFO"
    "jax._src": "WARNING" # Suppress JAX internal messages

# ==============================================================================
# QUALITY CONTROL (Optional)
# ==============================================================================
# Advanced quality control for data validation and analysis monitoring
quality_control:
  enabled: false # Enable quality control checks

  # Angle-specific quality checks
  angle_quality:
    validate_angle_coverage: true # Validate angle coverage adequacy
    min_angles_per_range: 1 # Minimum angles required per target range
    check_angle_distribution: true # Check angle distribution uniformity

  # Multi-angle data validation
  multi_angle_validation:
    check_correlation_consistency: true # Check correlation consistency across angles
    validate_angle_dependencies: true # Validate physical angle dependencies
    detect_anomalous_angles: true # Detect and warn about anomalous angles

# ==============================================================================
# VISUALIZATION (Optional)
# ==============================================================================
# Plot generation and output configuration
plotting:
  save_plots: true # Save plots to output directory
  show_plots: false # Display plots interactively
  format: "png" # Options: "png" | "pdf" | "svg"
  dpi: 300 # Resolution [dots per inch]
  style: "publication" # Plot style (matplotlib style name)

  # Rendering mode selection (hybrid plotting system)
  # Controls speed vs quality tradeoff for C2 heatmap plots
  preview_mode:
    false # false = publication quality (matplotlib, slower)
    # true = fast preview (Datashader, 5-10x faster)
  fit_surface: "solver" # Options: "solver" | "posthoc"

  color_scale:
    mode: "legacy" # Options: "legacy" | "adaptive"
    pin_legacy_range: true # When true, pin to [1.0, 1.5]
    percentile_min: 1.0 # Adaptive lower percentile
    percentile_max: 99.0 # Adaptive upper percentile
    fixed_min: 1.0 # Optional explicit minimum
    fixed_max: 1.5 # Optional explicit maximum

  # Datashader configuration (used when preview_mode: true)
  datashader:
    canvas_width: 1200 # Rendering resolution in pixels
    canvas_height: 1200 # Higher values = more detail, larger files
    # Note: CPU-only rendering in v2.3.0+

  # Matplotlib configuration (used when preview_mode: false)
  matplotlib:
    interpolation: "bilinear" # Options: "none" | "bilinear" | "bicubic"
    use_tight_layout: true # Use tight layout for plots
    savefig_kwargs:
      bbox_inches: "tight"
      pad_inches: 0.1

  # Plot types to generate
  correlation_function: true # C1(t) and C2(t1,t2) plots
  fit_quality: true # Residuals and fit quality plots
  parameter_distributions: true # Parameter posterior distributions (MCMC only)
  residual_analysis: true # Residual analysis plots

  # Angle-specific plots
  angle_coverage: true # Show which angles were used
  angle_correlation: true # Correlation quality vs angle

# ==============================================================================
# OUTPUT
# ==============================================================================
# Output file configuration
output:
  directory: "./results" # Base output directory
  base_directory: "./homodyne_results/" # Alternative: more descriptive directory name

  # Output formats
  formats:
    hdf5: true # Save results in HDF5 format
    json: true # Save results in JSON format
    csv: true # Save results in CSV format (tables only)

  # Output organization
  create_subdirs: true # Create method-specific subdirectories (nlsq/, mcmc/, cmc/)
  timestamp_dirs: false # Add timestamp to directory names

  # Compression
  compress_hdf5: true # Enable HDF5 compression (saves disk space)
  compression_level: 6 # HDF5 compression level (0-9, higher = more compression)

# ==============================================================================
# VALIDATION (Optional)
# ==============================================================================
# Configuration validation settings
validation:
  strict_mode: false # Fail on validation warnings
  check_file_existence: true # Verify data files exist before analysis
  validate_parameter_ranges: true # Check parameters are within reasonable physics bounds
  check_mode_compatibility: true # Verify configuration matches selected analysis mode

  # Angle validation
  angle_validation:
    require_multiple_angles: false # Require multiple phi angles (true for anisotropic analysis)
    min_angle_count: 1 # Minimum number of angles required
    validate_angle_ranges: true # Validate angle ranges are physically meaningful


# ==============================================================================
# CONFIGURATION NOTES AND USAGE GUIDANCE
# ==============================================================================
#
# PARAMETER NAMES:
# ----------------
# All parameter names now use canonical code names (no mapping needed):
#   gamma_dot_t0, gamma_dot_t_offset, phi0
#
# ANALYSIS MODES:
# ---------------
# static:
#   - 3 physical parameters: [D₀, α, D_offset]
#   - Per-angle scaling: [contrast, offset] × N angles
#   - Total: 3 + 2N parameters (e.g., 3 angles → 9 parameters)
#   - Use for: Equilibrium systems, pure diffusion
#
# laminar_flow:
#   - 7 physical parameters: [D₀, α, D_offset, γ̇₀, β, γ̇_offset, φ₀]
#   - Per-angle scaling: [contrast, offset] × N angles
#   - Total: 7 + 2N parameters (e.g., 3 angles → 13 parameters)
#   - Use for: Systems under shear flow, nonequilibrium dynamics
#
# OPTIMIZATION METHOD SELECTION (v2.1.0):
# ----------------------------------------
# NLSQ (Recommended for initial analysis):
#   - Fast, deterministic point estimates
#   - CPU-optimized with JAX 0.8.0 JIT compilation
#   - Automatic strategy based on dataset size
#   - Good for parameter estimation and exploration
#   - Runtime: seconds to minutes
#   - ⚠ CRITICAL FOR LAMINAR FLOW: Use x_scale_map to fix gradient imbalance
#
# MCMC (Recommended for publication with uncertainty quantification):
#   - Full posterior distributions with credible intervals
#   - Automatic NUTS/CMC selection based on dual criteria:
#     * (num_samples >= 15) OR (memory > 30%) → CMC (parallel sampling)
#     * Otherwise → NUTS (sequential sampling)
#   - Convergence diagnostics (R-hat, ESS, divergences)
#   - Manual workflow (v2.1.0+): Run NLSQ → copy results → update YAML → run MCMC
#   - No automatic NLSQ/SVI initialization (removed in v2.1.0)
#   - Runtime: minutes to hours (NUTS), hours to days (CMC)
#
# CRITICAL: GRADIENT IMBALANCE IN LAMINAR FLOW
# ---------------------------------------------
# Shear parameters (gamma_dot_t0, beta, gamma_dot_t_offset) can have gradients
# 100-10,000× larger than diffusion parameters (D0, alpha, D_offset).
#
# This causes:
#   - Premature convergence (optimizer stops while shear params still need work)
#   - Missing fine-scale features (decay oscillations near baseline)
#   - Poor fit quality despite low chi-squared values
#
# SOLUTION: Apply parameter-specific scaling via x_scale_map
#
# Step-by-step fix:
#   1. Run initial NLSQ optimization (without x_scale_map):
#      homodyne --config this_file.yaml --method nlsq
#
#   2. Diagnose gradient imbalance:
#      python scripts/diagnose_gradients.py --results-dir ./homodyne_results/nlsq --output x_scale_fix.yaml
#
#   3. Add recommended x_scale_map to optimization.nlsq section
#      (copy from diagnostic report output or x_scale_fix.yaml)
#
#   4. Re-run optimization with proper scaling:
#      homodyne --config this_file.yaml --method nlsq
#
#   5. Verify improved fit quality:
#      - Check that fitted c2 heatmaps show decay oscillations
#      - Verify chi-squared improvement (typically 10-50% reduction)
#      - Confirm more iterations completed (proper convergence, not premature)
#      - Ensure all parameters converged properly (not frozen at initial values)
#
# Streaming (Automatic for large datasets):
#   - Constant memory footprint
#   - Checkpoint/resume capability
#   - Handles > 100M points without memory errors
#   - Automatic fallback when other methods run out of memory
#
# DATASET SIZE HANDLING:
# ----------------------
# Automatic strategy selection (NLSQ):
#   < 1M points     → STANDARD (curve_fit)
#   1M-10M points   → LARGE (curve_fit_large)
#   10M-100M points → CHUNKED (progress tracking)
#   > 100M points   → STREAMING (checkpointing)
#
# PLATFORM SUPPORT (v2.3.0):
# ---------------------------
# CPU-only: Linux, macOS, Windows (full support, multi-core optimized)
# GPU support removed in v2.3.0 (use v2.2.1 for GPU features)
# HPC-ready: Optimized for 14+ core CPUs, tested on 36-128 core nodes
#
# Installation:
#   pip install homodyne  # Automatically installs CPU-only JAX 0.8.0
#
# Requirements:
#   - Python 3.12+
#   - JAX==0.8.0 and jaxlib==0.8.0 (exact match required, CPU-only)
#   - For GPU: Stay on homodyne v2.2.1 (last GPU-supporting version)
#
# ANGLE FILTERING:
# ----------------
# - Reduces parameter count (fewer angles = fewer scaling parameters)
# - All angles normalized to [-180°, 180°] range
# - Wrap-aware range checking (e.g., [170°, -170°] spans 20°, not 340°)
# - Recommended ranges:
#     Static: 0° and 180° (parallel and antiparallel)
#     Laminar flow: 0° and 90° (parallel and perpendicular to flow)
#
# BOUNDS OVERRIDE:
# ----------------
# Template bounds are physically reasonable defaults for typical XPCS systems.
# Code permits wider ranges (e.g., D0: 1-1e6 vs template: 100-1e5).
# Override template bounds via parameter_space.bounds if your system requires it.
#
# OUTPUT FILES:
# -------------
# results/
#   ├── nlsq/
#   │   ├── parameters.json              # Fitted parameters + uncertainties
#   │   ├── fitted_data.npz              # Experimental + theoretical data + residuals
#   │   ├── analysis_results_nlsq.json   # Fit quality metrics + dataset info
#   │   └── convergence_metrics.json     # Optimization convergence + recovery actions
#   ├── mcmc/
#   │   ├── parameters.json              # Posterior means + credible intervals
#   │   ├── samples.npz                  # Full posterior samples
#   │   ├── diagnostics.json             # R-hat, ESS, divergences
#   │   └── trace_plots.png              # MCMC trace plots
#   ├── cmc/
#   │   ├── combined_posterior.json      # Combined posterior from all shards
#   │   ├── per_shard_results.json       # Individual shard results
#   │   └── validation_metrics.json      # Between-shard convergence metrics
#   └── homodyne_results.json            # Legacy format (backward compatible)
#
# QUICK START WORKFLOWS:
# ----------------------
# 1. Static diffusion analysis:
#    - Copy homodyne_static.yaml
#    - Update experimental_data paths
#    - Run: homodyne --config config.yaml --method nlsq
#
# 2. Laminar flow analysis with uncertainty quantification (v2.1.0 workflow):
#    Step 1 - NLSQ optimization:
#      - Copy homodyne_laminar_flow.yaml
#      - Update paths and phi_filtering ranges
#      - Run: homodyne --config config.yaml --method nlsq
#      - Note best-fit parameters from output
#
#    Step 2 - Manual MCMC initialization (no automatic initialization in v2.1.0+):
#      - Manually copy NLSQ best-fit results from output
#      - Update initial_parameters.values in config.yaml with NLSQ results
#      - Example: values: [1234.5, 0.567, 12.34, 0.01, 0.0, 0.0, 0.0]
#      - Run: homodyne --config config.yaml --method mcmc
#      - Automatic NUTS/CMC selection based on dual criteria:
#        * (num_samples >= 15) OR (memory > 30%) → CMC
#        * Otherwise → NUTS
#
# 3. Large dataset (>100M points):
#    - NLSQ automatically uses streaming
#    - Enable checkpointing: optimization.streaming.enable_checkpoints: true
#    - Monitor progress in checkpoint_dir
#
# 4. Large-scale Bayesian inference (v2.1.0+):
#    - Set optimization.method: "mcmc"
#    - CMC automatically selected when dual criteria met:
#      * (num_samples >= 15) OR (memory > 30%)
#    - Configure cmc section for auto-selected CMC behavior
#    - Use cmc.backend_config for HPC systems (PBS/SLURM)
#    - No standalone --method cmc option (removed in v2.1.0)
#
# VALIDATION AND TESTING:
# -----------------------
# Validate configuration:
#   homodyne-config --validate config.yaml
#
# System health check:
#   python -m homodyne.runtime.utils.system_validator
#   python -m homodyne.runtime.utils.system_validator --quick
#
# Test with example data:
#   homodyne --config homodyne_static.yaml --plot-experimental-data
#
# DIAGNOSTIC TOOLS (NEW in v2.3.1):
# ----------------------------------
# Gradient imbalance diagnostic:
#   python scripts/diagnose_gradients.py --results-dir ./homodyne_results/nlsq
#   python scripts/diagnose_gradients.py --results-dir ./homodyne_results/nlsq --output x_scale_fix.yaml
#   python scripts/diagnose_gradients.py --quiet  # Just show recommendations
#
# Usage:
#   - Run AFTER initial NLSQ optimization
#   - Detects gradient imbalance causing missing oscillations
#   - Computes optimal x_scale_map values
#   - Saves recommendations to YAML for easy merging
#
# TROUBLESHOOTING COMMON ISSUES:
# -------------------------------
# Issue 1: Missing oscillations in fitted c2 heatmaps
#   Symptom: Smooth decay without characteristic homodyne oscillations near baseline
#   Cause: Gradient imbalance in laminar flow (shear params have 10,000× larger gradients)
#   Solution: Run gradient diagnostics and apply x_scale_map
#   Reference: docs/troubleshooting/gradient_imbalance_solution.md
#
# Issue 2: Premature convergence (optimizer stops early)
#   Symptom: Low iteration count (~50), parameters unchanged, chi-squared stagnant
#   Cause: Gradient imbalance causing trust region limits
#   Solution: Apply x_scale_map to normalize parameter steps
#   Check: diagnostics.log_jacobian_norms: true to see gradient magnitudes
#
# Issue 3: Silent NLSQ failure (0 iterations, zero gradients)
#   Symptom: Optimization returns immediately, parameters = initial values
#   Cause: Per-angle parameter incompatibility with NLSQ chunking (>100k points)
#   Solution: optimization.stratification.enabled: "auto" (default, should fix automatically)
#   Check: Verify stratification activated in logs
#   Reference: docs/releases/v2.2-stratification-release-notes.md
#
# Issue 4: High chi-squared despite convergence
#   Symptom: Optimization converged but fit quality poor
#   Cause: Wrong parameter bounds, missing x_scale_map, or physics model mismatch
#   Solution:
#     1. Check bounds are physically reasonable for your system
#     2. Run gradient diagnostics to check for imbalance
#     3. Verify analysis_mode matches system (static vs laminar_flow)
#     4. Check data quality (no NaN/Inf values)
#
# Issue 5: Out of memory errors
#   Symptom: Killed by OS, memory errors during optimization
#   Cause: Dataset too large for available memory
#   Solution:
#     1. Enable stratification.use_index_based: true (reduces memory 2x → ~1%)
#     2. Reduce stratification.target_chunk_size (e.g., 50000 instead of 100000)
#     3. Use streaming mode for >100M points (automatic)
#     4. For CMC: reduce cmc.backend_config.num_workers
#
# Issue 6: MCMC convergence failures (high R-hat, low ESS)
#   Symptom: R-hat > 1.1, ESS < 400, divergences present
#   Cause: Poor initialization, difficult posterior geometry, or insufficient warmup
#   Solution:
#     1. Initialize from NLSQ results (manual workflow v2.1.0+)
#     2. Increase mcmc.num_warmup (try 2000 for 7-parameter laminar flow)
#     3. Lower mcmc.target_accept_prob (try 0.65 if too many divergences)
#     4. Check parameter bounds not too restrictive
#     5. Verify priors are reasonable
#
# Issue 7: Very slow optimization (hours for NLSQ)
#   Symptom: Expected seconds/minutes, taking hours
#   Cause: Large dataset without proper chunking, or CPU underutilization
#   Solution:
#     1. Verify JAX JIT compilation enabled (performance.computation.enable_jit: true)
#     2. Check CPU thread usage (performance.computation.cpu_threads: "auto")
#     3. Use stratification for >100k points with per-angle scaling
#     4. Monitor memory usage - swapping causes severe slowdown
#
# DOCUMENTATION REFERENCES:
# -------------------------
# Gradient imbalance:
#   - docs/troubleshooting/gradient_imbalance_solution.md (complete guide)
#   - GRADIENT_IMBALANCE_FIX_SUMMARY.md (quick start)
#   - docs/troubleshooting/shear_gradient_check_20251112.md (original discovery)
#
# Stratification:
#   - docs/releases/v2.2-stratification-release-notes.md
#   - docs/architecture/nlsq-least-squares-solution.md
#
# NLSQ optimization:
#   - docs/troubleshooting/silent-failure-diagnosis.md
#   - docs/troubleshooting/nlsq-zero-iterations-investigation.md
#
# MCMC methods:
#   - docs/architecture/cmc-dual-mode-strategy.md
#   - docs/architecture/nuts-chain-parallelization.md
#   - docs/migration/v2.0-to-v2.1.md (NUTS/CMC auto-selection)
#
# Version history:
#   - docs/migration/v2.2-to-v2.3-gpu-removal.md (CPU-only transition)
#   - docs/migration/v2.0-to-v2.1.md (MCMC workflow changes)
#
# ==============================================================================
# END OF MASTER TEMPLATE
# ==============================================================================
