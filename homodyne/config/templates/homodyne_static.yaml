# ==============================================================================
# HOMODYNE STATIC DIFFUSION CONFIGURATION TEMPLATE
# ==============================================================================
# Production-ready template for static (equilibrium) diffusion analysis.
# 3-parameter model: D(t) = D₀·t^α + D_offset
#
# Use for: Equilibrium systems, pure diffusion, anomalous diffusion, aging
# Parameter count: 3 physical + 2 × N_angles scaling = 3 + 2N total
#
# For comprehensive documentation of all parameters, see:
#   homodyne_master_template.yaml
#
# VERSION: 2.22.1
# UPDATED: 2026-02-19
# ==============================================================================

# ==============================================================================
# METADATA
# ==============================================================================
metadata:
  config_version: "2.22.1"
  description: "Static diffusion analysis - 3-parameter model"
  analysis_mode: "static"
  parameter_count: 3

  # Physics model (no shear)
  physics_model: "D(t) = D₀·t^α + D_offset"

  # Numerical methods
  integration_method: "discrete_numerical"
  diagonal_correction: "mandatory"
  nlsq_cmc_physics_match: true

  # Template classification
  template_type: "production_ready"
  complexity: "focused"

  # Auto-filled by CLI
  generated_at: null
  generated_by: null

# ==============================================================================
# ANALYSIS MODE
# ==============================================================================
analysis_mode: "static"

# ==============================================================================
# ANALYZER PARAMETERS
# ==============================================================================
analyzer_parameters:
  dt: 0.001 # Time step [seconds]
  start_frame: 1 # Starting frame (1-indexed)
  end_frame: 2000 # Ending frame (inclusive)

  scattering:
    wavevector_q: 0.0054 # Wave vector [Å⁻¹]

  geometry:
    stator_rotor_gap: 2000000 # Gap [Å] (not used in static, kept for compatibility)

# ==============================================================================
# ANALYSIS SETTINGS
# ==============================================================================
analysis_settings:
  model_description:
    type: "static_diffusion"
    parameters: 3
    physics: "Equilibrium anomalous diffusion; C2 diagonal correction enforced"

# ==============================================================================
# EXPERIMENTAL DATA
# ==============================================================================
experimental_data:
  file_path: "./data/sample/experiment.hdf"

  # Legacy composite path
  data_folder_path: "./data/sample/"
  data_file_name: "experiment.hdf"

  # Phi angles
  phi_angles_path: "./data/sample/"
  phi_angles_file: "phi_angles_list.txt"

  # Caching
  cache_file_path: "./data/sample/"
  cache_filename_template: "cached_c2_static_q{wavevector_q:.4f}_frames_{start_frame}_{end_frame}.npz"
  cache_compression: true

  # Format
  data_type: "float64"
  file_format: "HDF5"
  exchange_key: "exchange"

# ==============================================================================
# PHI ANGLE FILTERING
# ==============================================================================
# For static diffusion: 0° and 180° detect anisotropy; all angles for isotropic
phi_filtering:
  enabled: true

  target_ranges:
    - min_angle: -10.0
      max_angle: 10.0
      description: "Parallel to primary axis"
    - min_angle: 170.0
      max_angle: -170.0 # Wrap-aware: 170° to -170°
      description: "Antiparallel"
    # Optional for anisotropic analysis:
    # - min_angle: 85.0
    #   max_angle: 95.0
    #   description: "Perpendicular"

  fallback_to_all_angles: true
  algorithm: "range_based"
  tolerance: 3.0

  quality_control:
    min_angles_required: 1
    max_angle_spread: 36.0
    validate_coverage: true
    require_orthogonal_angles: false # Not required for static

# ==============================================================================
# INITIAL PARAMETERS
# ==============================================================================
# Total = 3 physical + 2 × N_angles (per-angle contrast + offset)
# Example: 3 angles → 9 parameters
initial_parameters:
  parameter_names:
    - D0 # Diffusion prefactor [Å²/s]
    - alpha # Anomalous exponent
    - D_offset # Baseline diffusion [Å²/s]

  # Initial values: null = mid-bounds, or list of 3 floats
  values: null
  # Example: [1000.0, -1.2, 0.0]

  # Per-angle scaling (one value per filtered angle)
  # v2.17.0+: Quantile-based initialization computes robust initial values
  # from experimental data using quantile statistics when null
  per_angle_scaling:
    contrast: null # null = quantile-based init, or [0.05, 0.06] for 2 angles
    offset: null # null = quantile-based init, or [1.0, 0.99] for 2 angles

  units:
    - "Å²/s"
    - "dimensionless"
    - "Å²/s"

  # Optional: Optimize subset of parameters
  active_parameters: null # e.g., ["D0", "alpha"]

  # Optional: Fix parameters at specific values
  fixed_parameters: null # e.g., {"D_offset": 0.0}

# ==============================================================================
# PARAMETER SPACE
# ==============================================================================
parameter_space:
  model: "static"

  bounds:
    # Scaling parameters
    - name: contrast
      min: 0.0
      max: 1.0
      type: TruncatedNormal

    - name: offset
      min: 0.5
      max: 1.5
      type: TruncatedNormal

    # Diffusion parameters
    - name: D0
      min: 100.0
      max: 100000.0
      type: TruncatedNormal
      prior_mu: 1000.0
      prior_sigma: 1000.0
      unit: "Å²/s"

    - name: alpha
      min: -2.0
      max: 2.0
      type: TruncatedNormal
      prior_mu: -1.2 # Subdiffusion common in equilibrium
      prior_sigma: 0.3
      unit: "dimensionless"

    - name: D_offset
      min: -100000.0
      max: 100000.0
      type: TruncatedNormal
      prior_mu: 0.0
      prior_sigma: 150.0
      unit: "Å²/s"

  # Data-driven priors for MCMC (optional)
  priors:
    contrast:
      dist_type: TruncatedNormal
      mu: 0.06 # Static typically has lower contrast
      sigma: 0.05
      min_val: 0.0
      max_val: 0.5

    offset:
      dist_type: TruncatedNormal
      mu: 1.0
      sigma: 0.1
      min_val: 0.8
      max_val: 1.2

# ==============================================================================
# OPTIMIZATION
# ==============================================================================
optimization:
  method: "nlsq"

  # ===========================================================================
  # NLSQ - Trust-Region Nonlinear Least Squares
  # ===========================================================================
  nlsq:
    workflow: "auto"
    goal: "quality"

    # Memory configuration
    memory_fraction: 0.75 # Use 75% of available RAM
    # memory_threshold_gb: 48.0       # OR: explicit threshold

    # Convergence settings
    max_iterations: 100
    tolerance: 1.0e-8 # Function tolerance (ftol)
    xtol: 1.0e-8 # Parameter tolerance
    gtol: 1.0e-8 # Gradient tolerance
    trust_region_scale: 1.0
    verbose: false

    # Loss function
    loss: "soft_l1" # Recommended for XPCS data

    # Parameter scaling (less critical for static - similar parameter scales)
    x_scale_map: null

    # Progress
    progress:
      enable: true
      verbose: 1
      log_interval: 10

    # Diagnostics
    diagnostics:
      enabled: false
      sample_size: 2048
      check_gradients: true
      log_jacobian_norms: false

    # -------------------------------------------------------------------------
    # HYBRID STREAMING (>10M points)
    # -------------------------------------------------------------------------
    hybrid_streaming:
      enable: true
      normalize: true
      normalization_strategy: "auto"
      warmup_iterations: 200
      max_warmup_iterations: 500
      warmup_learning_rate: 0.001
      gauss_newton_max_iterations: 100
      gauss_newton_tol: 1.0e-8
      chunk_size: 10000
      trust_region_initial: 1.0
      regularization_factor: 1.0e-10
      enable_checkpoints: true
      checkpoint_frequency: 100
      validate_numerics: true
      verbose: 1
      log_frequency: 1

      # 4-Layer Defense Strategy
      enable_warm_start_detection: true
      warm_start_threshold: 0.01
      enable_adaptive_warmup_lr: true
      warmup_lr_refinement: 1.0e-6
      warmup_lr_careful: 1.0e-5
      enable_cost_guard: true
      cost_increase_tolerance: 0.05
      enable_step_clipping: true
      max_warmup_step_size: 0.1

    # -------------------------------------------------------------------------
    # ANTI-DEGENERACY (Minimal for Static Mode)
    # -------------------------------------------------------------------------
    # Static mode has only 3 physical parameters with similar scales.
    # Anti-degeneracy system is designed for laminar_flow gradient cancellation.
    # Disabled by default; enable only if parameter collapse observed.
    anti_degeneracy:
      enable: false # Not needed for static mode
      # Per-angle mode selection (v2.18.0+):
      # Static mode has only 3 physical parameters with similar scales.
      # Anti-degeneracy is less critical but available if needed.
      # Same logic as CMC per-angle mode (except NLSQ also has "fourier").
      #
      #   "auto": Uses constant when n_phi >= threshold
      #   "constant": Per-angle values from quantile estimation, used directly
      #   "fourier": Fourier basis (NLSQ only)
      #   "individual": Independent per-angle params, optimized
      #
      per_angle_mode: "auto"
      constant_scaling_threshold: 3

      gradient_monitoring:
        enable: true # Lightweight diagnostic only
        ratio_threshold: 0.01
        consecutive_triggers: 5
        response: "warn" # Just warn, don't intervene

    # -------------------------------------------------------------------------
    # MULTI-START OPTIMIZATION
    # -------------------------------------------------------------------------
    # For static mode, multi-start OR standard NLSQ is usually sufficient
    # (parameters have similar scales, no need for CMA-ES global search)
    multi_start:
      enable: false # Enable for uncertain initial guesses
      n_starts: 10
      seed: 42
      sampling_strategy: "latin_hypercube"
      n_workers: 0
      use_screening: true
      screen_keep_fraction: 0.5
      refine_top_k: 3
      refinement_ftol: 1.0e-12
      degeneracy_threshold: 0.1

    # -------------------------------------------------------------------------
    # CMA-ES GLOBAL OPTIMIZATION
    # -------------------------------------------------------------------------
    # Usually overkill for static mode (similar parameter scales).
    # Consider multi-start instead.
    cmaes:
      enable: false # Static mode typically doesn't need CMA-ES
      preset: "cmaes-global" # 200 generations for better global convergence
      max_generations: 200 # Increased from 100
      sigma: 0.3 # Smaller initial step for refined search
      popsize: 30 # Larger population for robust optimization
      tol_fun: 1.0e-8
      tol_x: 1.0e-8
      restart_strategy: "bipop"
      max_restarts: 15 # More restarts to escape local minima
      population_batch_size: null
      data_chunk_size: null
      memory_limit_gb: 8.0
      auto_select: false # Disabled for static (similar scales)
      scale_threshold: 1000.0

      # CMA-ES Parameter Normalization (v2.16.0)
      normalize: true            # Enable bounds-based normalization
      normalization_epsilon: 1.0e-12  # Prevent division by zero

      # Post-CMA-ES refinement
      refine_with_nlsq: true
      refinement_workflow: "auto"
      refinement_ftol: 1.0e-10
      refinement_xtol: 1.0e-10
      refinement_gtol: 1.0e-10
      refinement_max_nfev: 500
      refinement_loss: "linear"

    # -------------------------------------------------------------------------
    # FIT QUALITY VALIDATION (v2.16.0+)
    # -------------------------------------------------------------------------
    quality_validation:
      enable: true
      reduced_chi_squared_threshold: 10.0
      warn_on_max_restarts: true
      warn_on_bounds_hit: true
      warn_on_convergence_failure: true
      bounds_tolerance: 1.0e-9

  # ===========================================================================
  # STREAMING (>100M points)
  # ===========================================================================
  streaming:
    enable_checkpoints: true
    checkpoint_dir: "./checkpoints"
    checkpoint_frequency: 10
    resume_from_checkpoint: true
    keep_last_checkpoints: 3
    enable_fault_tolerance: true
    max_retries_per_batch: 2
    min_success_rate: 0.5
    batch_size: null
    adaptive_batching: true

  # ===========================================================================
  # STRATIFICATION
  # ===========================================================================
  stratification:
    enabled: "auto"
    target_chunk_size: 100000
    max_imbalance_ratio: 5.0
    force_sequential_fallback: false
    check_memory_safety: true
    use_index_based: false
    collect_diagnostics: false
    log_diagnostics: false

  # ===========================================================================
  # SEQUENTIAL FALLBACK
  # ===========================================================================
  sequential:
    min_success_rate: 0.5
    weighting: "inverse_variance"

  # ===========================================================================
  # RECOVERY
  # ===========================================================================
  recovery:
    enable: true
    max_attempts: 3
    lr_decay: 0.5
    lambda_growth: 2.0
    trust_decay: 0.5
    log_retries: true

  # ===========================================================================
  # MCMC - Base Configuration
  # ===========================================================================
  mcmc:
    backend: "numpyro"
    num_warmup: 1000 # More warmup OK for 3 params
    num_samples: 3000
    num_chains: 4
    progress_bar: true
    target_accept_prob: 0.90
    max_tree_depth: 12
    dense_mass_matrix: true

    initial_values:
      phi: {}
      percentile_fallback:
        contrast_low_pct: 5
        contrast_high_pct: 95
        offset_pct: 50

  # ===========================================================================
  # CMC - Consensus Monte Carlo
  # ===========================================================================
  # AUTOMATIC NLSQ WARM-START (v2.20.0):
  #   CLI: homodyne --method cmc → NLSQ runs first automatically
  #   Reduces divergence rate; less critical for static (simpler 3-param model)
  #
  cmc:
    enable: "auto"
    min_points_for_cmc: 500000 # Higher threshold for simpler model
    run_id: null
    backend: "jax"

    # Anti-degeneracy: Per-angle scaling mode (v2.18.0+)
    # Less critical for static mode (no shear gradient cancellation).
    # Same logic as NLSQ per-angle mode (except CMC does not have "fourier").
    #
    #   "auto": Auto-selects based on n_phi threshold.
    #     When n_phi >= threshold: Estimates per-angle, AVERAGES, broadcasts.
    #
    #   "constant": Per-angle values from quantile estimation, used DIRECTLY.
    #     Different fixed value per angle (NOT averaged).
    #
    #   "individual": Per-angle contrast/offset sampled.
    #
    per_angle_mode: "auto"
    constant_scaling_threshold: 3 # Use constant when n_phi >= this

    # Prior tempering (v2.22.1): Scales priors by 1/K per shard
    prior_tempering: true

    backend_config:
      name: "auto"
      enable_checkpoints: true
      checkpoint_frequency: 1
      checkpoint_dir: "./checkpoints/cmc"
      keep_last_checkpoints: 3
      resume_from_checkpoint: true

    sharding:
      strategy: "random"
      num_shards: "auto"
      max_points_per_shard: "auto" # 50K-100K for static (10x larger than laminar)
      min_points_per_shard: 10000 # Minimum shard size
      seed_base: 0
      min_points_per_param: 1500 # Minimum points per parameter per shard

    per_shard_timeout: 3600 # 1 hour (static converges faster)
    heartbeat_timeout: 600

    combination:
      method: "robust_consensus_mc" # MAD-based outlier detection (default since v2.22.1)
      validate_results: true
      min_success_rate: 0.90 # Higher for simpler model
      min_success_rate_warning: 0.80

    per_shard_mcmc:
      num_warmup: 500
      num_samples: 1500
      num_chains: 4
      target_accept_prob: 0.85

      # -----------------------------------------------------------------------
      # ADAPTIVE SAMPLING (v2.22.0 / Feb 2026)
      # -----------------------------------------------------------------------
      # Automatically reduces warmup/samples for small datasets to decrease
      # NUTS overhead. Profiling showed 1310s for 50 points with defaults;
      # adaptive scaling reduces this by 60-80%.
      #
      # Scaling: shard_size / 10000 → scale factor (capped at 1.0)
      #   50 pts → 140 warmup, 350 samples (75% reduction)
      #   5000 pts → 250 warmup, 750 samples (50% reduction)
      #   50000+ pts → full defaults (no reduction)
      adaptive_sampling: true # Enable adaptive sample count
      max_tree_depth: 10 # NUTS tree depth (max 2^depth leapfrog steps)
      min_warmup: 100 # Minimum warmup even for tiny datasets
      min_samples: 200 # Minimum samples for statistical validity

      # -----------------------------------------------------------------------
      # JAX PROFILING (v2.22.0 / Feb 2026)
      # -----------------------------------------------------------------------
      # py-spy only profiles Python code; XLA runs native code invisible to it.
      # Enable JAX profiling to capture XLA-level performance data.
      # View with: tensorboard --logdir=./profiles/jax
      enable_jax_profiling: false # Enable jax.profiler tracing
      jax_profile_dir: ./profiles/jax # Output directory for JAX traces

    validation:
      strict_mode: true # Strict OK for simpler model
      min_per_shard_ess: 100.0
      max_per_shard_rhat: 1.1
      max_between_shard_kl: 2.0
      min_success_rate: 0.90

      # NLSQ warm-start & quality control (v2.20.0)
      # NOTE: CLI automatically runs NLSQ before CMC (homodyne --method cmc)
      max_divergence_rate: 0.10 # Filter shards with >10% divergences
      require_nlsq_warmstart: false # Optional for static (simpler model)

      # NLSQ-informed priors (v2.22.1)
      use_nlsq_informed_priors: true
      nlsq_prior_width_factor: 2.0
      max_parameter_cv: 1.5 # Higher threshold OK for static
      heterogeneity_abort: true # Abort with guidance if CV exceeded

    # -------------------------------------------------------------------------
    # REPARAMETERIZATION (v2.21.0 / Jan 2026)
    # -------------------------------------------------------------------------
    # Transforms sampling space to break D0/D_offset degeneracy.
    # Less critical for static mode (no shear parameters) but still beneficial.
    #
    # D_total Reparameterization:
    #   Sample D_total = D0 + D_offset instead of D0 directly.
    #   Breaks the linear degeneracy between D0 and D_offset.
    #
    # Log-Gamma Reparameterization:
    #   Not applicable to static mode (no gamma_dot_t0 parameter).
    #   Included for consistency; has no effect.
    #
    # Bimodal Detection:
    #   Post-sampling GMM analysis to detect bimodal posteriors.
    #
    reparameterization:
      enable_d_total: true # Sample D_total = D0 + D_offset
      enable_log_gamma: false # N/A for static (no shear params)
      bimodal_min_weight:
        0.2 # Minimum GMM component weight
        # CONSTRAINT: (0, 0.5]
      bimodal_min_separation:
        0.5 # Minimum relative separation
        # CONSTRAINT: (0, 2.0]

# ==============================================================================
# NOISE ESTIMATION (Optional)
# ==============================================================================
noise_estimation:
  enabled: false
  model: "per_angle"

  adam_config:
    learning_rate: 0.01
    max_epochs: 500
    convergence_threshold: 1.0e-6
    early_stopping: true

  posterior_samples: 1200

  validation:
    check_convergence: true
    reasonable_range: [1.0e-4, 1.0]
    warn_outliers: true

  per_angle:
    min_angles_required: 2
    validate_coverage: true

# ==============================================================================
# PERFORMANCE
# ==============================================================================
performance:
  strategy_override: null
  memory_limit_gb: null
  enable_progress: true

  memory_optimization:
    enabled: true
    max_memory_usage_gb: 6.0
    chunk_size: 8000
    enable_caching: true
    cache_strategy: "adaptive"

  computation:
    enable_jit: true
    cpu_threads: "auto"
    vectorization_level: "high"

# ==============================================================================
# LOGGING
# ==============================================================================
logging:
  enabled: true
  level: "INFO"

  console:
    enabled: true
    level: "INFO"
    format: "detailed"
    colors: true
    show_progress: true

  file:
    enabled: false
    level: "DEBUG"
    path: "./logs/"
    filename: "homodyne_static.log"
    max_size_mb: 10
    backup_count: 5

  modules:
    "homodyne.data.phi_filtering": "INFO"
    "homodyne.data.xpcs_loader": "INFO"
    "homodyne.optimization.nlsq_wrapper": "INFO"
    "jax._src": "WARNING"

# ==============================================================================
# QUALITY CONTROL (Optional)
# ==============================================================================
quality_control:
  enabled: false

  angle_quality:
    validate_angle_coverage: true
    min_angles_per_range: 1
    check_angle_distribution: true

  multi_angle_validation:
    check_correlation_consistency: true
    validate_angle_dependencies: true
    detect_anomalous_angles: true

# ==============================================================================
# PLOTTING
# ==============================================================================
plotting:
  save_plots: true
  show_plots: false
  format: "png"
  dpi: 300
  style: "publication"

  preview_mode: false
  fit_surface: "solver"

  color_scale:
    mode: "legacy"
    pin_legacy_range: true
    percentile_min: 1.0
    percentile_max: 99.0
    fixed_min: 1.0
    fixed_max: 1.5

  datashader:
    canvas_width: 1200
    canvas_height: 1200

  matplotlib:
    interpolation: "bilinear"
    use_tight_layout: true
    savefig_kwargs:
      bbox_inches: "tight"
      pad_inches: 0.1

  correlation_function: true
  fit_quality: true
  parameter_distributions: true
  residual_analysis: true
  angle_coverage: true
  angle_correlation: true

# ==============================================================================
# OUTPUT
# ==============================================================================
output:
  directory: "./results"
  base_directory: "./homodyne_results/"

  formats:
    hdf5: true
    json: true
    csv: true

  create_subdirs: true
  timestamp_dirs: false
  compress_hdf5: true
  compression_level: 6

# ==============================================================================
# VALIDATION (Optional)
# ==============================================================================
validation:
  strict_mode: false
  check_file_existence: true
  validate_parameter_ranges: true
  check_mode_compatibility: true

  angle_validation:
    require_multiple_angles: false
    min_angle_count: 1
    validate_angle_ranges: true

# ==============================================================================
# STATIC DIFFUSION - QUICK REFERENCE
# ==============================================================================
#
# WORKFLOW:
# ---------
# 1. Update experimental_data paths
# 2. Adjust phi_filtering (0°/180° for anisotropy, all angles for isotropic)
# 3. Run NLSQ: homodyne --config this_file.yaml --method nlsq
# 4. Copy NLSQ results to initial_parameters.values
# 5. Run MCMC: homodyne --config this_file.yaml --method mcmc
#
# PARAMETER COUNTING:
# -------------------
# Total = 3 physical + 2 × N_angles
# Example: 3 angles → 9 parameters
#
# PHYSICAL INTERPRETATION:
# ------------------------
# D₀: Diffusion magnitude (100-10000 Å²/s)
# α: Anomalous exponent (0=normal, <0=subdiffusion, >0=superdiffusion)
# D_offset: Baseline diffusion (-100 to 100 Å²/s, can be negative for jammed)
#
# STATIC vs LAMINAR_FLOW:
# -----------------------
# - Anti-degeneracy disabled (no shear gradient cancellation)
# - CMA-ES auto_select disabled (similar parameter scales)
# - Larger CMC shards (100k vs 20k - simpler posteriors)
# - Higher CMC success threshold (0.90 vs 0.80)
# - Strict validation mode OK
#
# VALIDATION:
# -----------
# homodyne-config --validate this_file.yaml
#
# ==============================================================================
# END OF STATIC DIFFUSION TEMPLATE
# ==============================================================================
