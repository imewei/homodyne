{
  "_template_info": {
    "_comment": "COMPREHENSIVE HOMODYNE CONFIGURATION TEMPLATE - Based on current codebase v0.7.2",
    "_creation_date": "2025-09-03",
    "_based_on_analysis": "All existing config files (static_isotropic, static_anisotropic, laminar_flow) merged with recent enhancements including comprehensive shell aliases and improved completion system",
    "_usage": "Copy this template and customize the analysis_mode, initial_parameters, and experimental_data sections for your specific experiment",
    "_config_modes": {
      "static_isotropic": "3-parameter optimization [D0, alpha, D_offset] - no angle filtering",
      "static_anisotropic": "3-parameter optimization [D0, alpha, D_offset] - with angle filtering",
      "laminar_flow": "7-parameter optimization [D0, alpha, D_offset, gamma_dot_t0, beta, gamma_dot_t_offset, phi0] - full flow dynamics"
    }
  },
  "metadata": {
    "_comment": "Template metadata - Customize description and analysis_mode for your experiment",
    "config_version": "0.7.2",
    "description": "TEMPLATE: Comprehensive homodyne scattering analysis configuration",
    "based_on": "He et al. PNAS 2024 - Transport coefficient approach",
    "analysis_mode": "CHANGE_ME: static_isotropic | static_anisotropic | laminar_flow",
    "plotting_features": {
      "experimental_data_plotting": "Use --plot-experimental-data or 'hexp' shortcut for validation and comparison",
      "simulated_data_plotting": "Use --plot-simulated-data or 'hsim' shortcut with --contrast and --offset parameters",
      "phi_angles_override": "Command-line --phi-angles overrides config file settings",
      "multi_method_support": "Separate plots generated for each optimization method (Nelder-Mead, Gurobi, etc.)"
    },
    "parameters_optimized": "DEPENDS_ON_MODE: [D0,alpha,D_offset] for static modes, [D0,alpha,D_offset,gamma_dot_t0,beta,gamma_dot_t_offset,phi0] for laminar_flow",
    "shell_completion": "Interactive mode removed - comprehensive shell aliases available: hm, hc, hr, ha (methods), hconfig, hexp, hsim (utilities), hc-iso, hc-aniso, hc-flow (config shortcuts), hgm, hga (GPU)",
    "script_compatibility": "homodyne v0.7.2 with fast shell completion and code consolidation"
  },
  "experimental_data": {
    "_comment": "CUSTOMIZE: Update paths and filenames for your experimental data",
    "data_folder_path": "./data/YOUR_SAMPLE_NAME/",
    "data_file_name": "your_experimental_data.hdf",
    "phi_angles_path": "./data/phi_angles/",
    "phi_angles_file": "phi_list.txt",
    "exchange_key": "exchange",
    "cache_file_path": "./data/YOUR_SAMPLE_NAME/",
    "cache_filename_template": "cached_c2_frames_{start_frame}_{end_frame}.npz",
    "cache_compression": true,
    "data_type": "float64",
    "file_format": "NPZ",
    "preprocessing": {
      "apply_diagonal_correction": true,
      "vectorized_correction": true,
      "cache_processed_data": true,
      "normalize_data": true,
      "normalization_method": "baseline"
    }
  },
  "analyzer_parameters": {
    "_comment": "CUSTOMIZE: Core physics parameters for your experiment",
    "temporal": {
      "dt": 0.1,
      "_dt_note": "Time step between frames in seconds - CUSTOMIZE for your acquisition",
      "dt_unit": "seconds",
      "start_frame": 100,
      "_start_frame_note": "CUSTOMIZE: Skip initial frames for equilibration",
      "end_frame": 1000,
      "_end_frame_note": "CUSTOMIZE: Total analysis window",
      "frame_description": "Analysis time window for experiment"
    },
    "scattering": {
      "wavevector_q": 0.001,
      "_q_note": "CUSTOMIZE: Scattering wavevector q = 4π sin(θ/2)/λ",
      "q_unit": "Å⁻¹",
      "typical_range": [
        0.001,
        0.1
      ]
    },
    "geometry": {
      "stator_rotor_gap": 2000000,
      "_gap_note": "CUSTOMIZE: Gap in Angstroms - critical for laminar_flow, less important for static modes",
      "gap_unit": "Å",
      "gap_in_microns": 200
    },
    "computational": {
      "num_threads": "auto",
      "auto_detect_cores": true,
      "max_threads_limit": 16,
      "_max_threads_note": "Adjust based on your system - laminar_flow needs more threads",
      "memory_limit_gb": 16
    }
  },
  "initial_parameters": {
    "_comment": "CUSTOMIZE: Starting values - CRITICAL for convergence. Adjust based on your analysis_mode",
    "_mode_dependent_note": "Parameter count depends on analysis_mode: 3 for static modes, 7 for laminar_flow",
    "values": "MODE_DEPENDENT: [100.0,0.0,10.0] for static, [100.0,0.0,10.0,1.0,0.0,0.0,0.0] for laminar_flow",
    "parameter_names": "MODE_DEPENDENT: See _parameter_definitions below",
    "_parameter_definitions": {
      "static_modes": [
        "D0",
        "alpha",
        "D_offset"
      ],
      "laminar_flow": [
        "D0",
        "alpha",
        "D_offset",
        "gamma_dot_t0",
        "beta",
        "gamma_dot_t_offset",
        "phi0"
      ]
    },
    "units": "MODE_DEPENDENT: [Å²/s,dimensionless,Å²/s] for static, [Å²/s,dimensionless,Å²/s,s⁻¹,dimensionless,s⁻¹,degrees] for laminar_flow",
    "physical_meaning": {
      "_common_to_all_modes": {
        "D0": "Reference diffusion coefficient",
        "alpha": "Power-law exponent for D(t) evolution",
        "D_offset": "Baseline diffusion coefficient"
      },
      "_laminar_flow_additional": {
        "gamma_dot_t0": "Reference shear rate",
        "beta": "Power-law exponent for shear rate evolution",
        "gamma_dot_t_offset": "Baseline shear rate",
        "phi0": "Angular offset between flow and scattering"
      }
    },
    "active_parameters": "MODE_DEPENDENT: Matches parameter_names above",
    "parameter_units": "MODE_DEPENDENT: Matches units above in dict format"
  },
  "optimization_config": {
    "_comment": "Comprehensive optimization settings with enhanced Gurobi and robust methods",
    "angle_filtering": {
      "_mode_dependent": "disabled for static_isotropic, enabled for static_anisotropic and laminar_flow",
      "enabled": "MODE_DEPENDENT: false for static_isotropic, true for others",
      "target_ranges": [
        {
          "min_angle": -10.0,
          "max_angle": 10.0
        },
        {
          "min_angle": 80.0,
          "max_angle": 100.0,
          "_note": "static_anisotropic only"
        },
        {
          "min_angle": 170.0,
          "max_angle": 190.0
        },
        {
          "min_angle": 260.0,
          "max_angle": 280.0,
          "_note": "static_anisotropic only"
        }
      ],
      "fallback_to_all_angles": true,
      "_performance_note": "Provides 3-5x speedup for complex optimization"
    },
    "classical_optimization": {
      "methods": [
        "Nelder-Mead",
        "Gurobi"
      ],
      "_methods_note": "Classical methods always available. Robust methods in separate section below.",
      "_method_flags": {
        "--method classical": "Runs ONLY classical methods: Nelder-Mead, Gurobi (if licensed)",
        "--method robust": "Runs ONLY robust methods: Robust-Wasserstein, Robust-Scenario, Robust-Ellipsoidal",
        "--method mcmc": "Runs ONLY Bayesian MCMC sampling for uncertainty quantification",
        "--method all": "Runs classical + robust + MCMC for comprehensive analysis"
      },
      "_gurobi_availability": "Requires Gurobi license (pip install gurobipy). Now uses enhanced Trust Region SQP.",
      "method_options": {
        "Nelder-Mead": {
          "maxiter": "MODE_DEPENDENT: 2000 for static, 4000 for laminar_flow",
          "_maxiter_note": "Optimized for scientific data fitting - more iterations rarely help",
          "_dataset_scaling": "For large datasets (>1M points): reduce to 1500/3000 for efficiency",
          "xatol": 1e-06,
          "_xatol_note": "Realistic parameter tolerance for experimental data with noise",
          "_large_dataset_xatol": "For >5M points: consider 5e-6 for faster convergence",
          "fatol": 1e-06,
          "_fatol_note": "Practical chi-squared tolerance for noisy data fitting",
          "_large_dataset_fatol": "For >5M points: consider 5e-6 to balance precision vs speed",
          "adaptive": true,
          "_adaptive_note": "Adaptive step sizes essential for robust convergence",
          "initial_simplex": null,
          "_initial_simplex_note": "Auto-generated based on parameter bounds",
          "return_all": false,
          "_return_all_note": "Return only final result for efficiency"
        },
        "Gurobi": {
          "_comment": "ENHANCED: Now uses iterative Trust Region SQP instead of single-shot QP (fixes χ² convergence)",
          "_algorithm": "Iterative trust region SQP optimization with quadratic approximation and adaptive radius",
          "max_iterations": "MODE_DEPENDENT: 300 for static, 800 for laminar_flow",
          "_max_iterations_note": "Sufficient iterations for convergence without computational waste",
          "tolerance": 1e-05,
          "_tolerance_note": "Realistic convergence tolerance for experimental data",
          "output_flag": 0,
          "_output_flag_note": "Gurobi verbosity (0=silent, 1=verbose)",
          "method": 2,
          "_method_note": "Barrier method optimized for trust region subproblems",
          "time_limit": "MODE_DEPENDENT: 180s for static, 480s for laminar_flow",
          "_time_limit_note": "Balanced time limits for practical workflows",
          "_trust_region_settings": {
            "initial_radius": 5.0,
            "max_radius": 50.0,
            "eta1": 0.1,
            "eta2": 0.8,
            "gamma1": 0.5,
            "gamma2": 3.0,
            "max_trust_iterations": 150,
            "_note": "Optimized trust region parameters for faster convergence",
            "_rationale": "Larger initial radius and more aggressive expansion for scientific optimization"
          },
          "_advantages": "Better convergence than old single-shot QP, handles bounds naturally",
          "_requirements": "Gurobi license required for enhanced optimization performance",
          "gradient_optimization": {
            "_comment": "Advanced gradient calculation optimization for reduced function evaluations",
            "adaptive_step_sizing": {
              "enabled": true,
              "base_epsilon": 1e-8,
              "_base_epsilon_note": "Minimum finite difference step size",
              "relative_factor": 0.01,
              "_relative_factor_note": "Step size as fraction of parameter magnitude (1% default)",
              "bounds_proximity_factor": 0.1,
              "_bounds_proximity_factor_note": "Reduce step size when within this fraction of parameter bounds"
            },
            "boundary_aware_differences": {
              "enabled": true,
              "boundary_tolerance": 0.05,
              "_boundary_tolerance_note": "Use forward/backward differences when within this fraction of bounds",
              "prefer_central": true,
              "_prefer_central_note": "Use central differences when possible for better accuracy"
            },
            "smart_scheduling": {
              "enabled": true,
              "base_frequency": "MODE_DEPENDENT: 2 for static, 3 for laminar_flow",
              "_base_frequency_note": "Calculate gradient every N iterations (adaptive based on convergence)",
              "adaptive_scheduling": true,
              "_adaptive_scheduling_note": "Adjust frequency based on gradient norm and trust region changes",
              "force_recalc_conditions": {
                "trust_region_change_threshold": 0.5,
                "gradient_norm_threshold": 1e-3,
                "_conditions_note": "Force gradient recalculation when these conditions are met"
              }
            },
            "enhanced_caching": {
              "enabled": true,
              "similarity_threshold": 1e-4,
              "_similarity_threshold_note": "Reuse cached gradient when parameters change less than this (relative)",
              "max_cache_size": 256,
              "cache_strategy": "lru",
              "_cache_strategy_options": ["lru", "fifo", "size_based"]
            },
            "combined_calculations": {
              "enabled": true,
              "_note": "Compute gradient and Hessian together to eliminate redundant function evaluations",
              "three_point_stencil": true,
              "_three_point_stencil_note": "Use f(x-h), f(x), f(x+h) for both gradient and Hessian"
            },
            "monitoring": {
              "enabled": false,
              "log_statistics": false,
              "_log_statistics_note": "Log gradient calculation statistics for performance analysis",
              "track_function_evaluations": true,
              "_track_function_evaluations_note": "Count and report function evaluations saved"
            }
          }
        }
      },
      "batch_processing": {
        "_comment": "ENHANCED v0.8.0+: Batch processing optimization with multiple initial points and parallel execution",
        "enabled": true,
        "max_parallel_runs": "MODE_DEPENDENT: 4 for static, 6 for laminar_flow",
        "_max_parallel_runs_note": "Number of simultaneous optimization runs - balance between speed and resource usage",
        "multiple_initial_points": true,
        "_multiple_initial_points_note": "Use multiple starting points to find global optimum and avoid local minima",
        "initial_point_strategy": "latin_hypercube",
        "_initial_point_strategy_options": {
          "latin_hypercube": "Optimal space coverage for efficient parameter exploration (recommended)",
          "random": "Simple random sampling - faster but less systematic",
          "grid": "Grid-based sampling - thorough but computationally expensive for high dimensions"
        },
        "num_initial_points": "MODE_DEPENDENT: 8 for static, 12 for laminar_flow",
        "_num_initial_points_note": "More points increase global optimization reliability but require more computation time",
        "convergence_threshold": 0.01,
        "_convergence_threshold_note": "Early stopping when multiple runs converge to similar objectives (fraction of best objective)",
        "_performance_benefits": [
          "Significantly improved global optimization reliability",
          "Parallel execution reduces wall-clock time",
          "Early convergence detection prevents unnecessary computation",
          "Latin hypercube sampling ensures comprehensive parameter space exploration",
          "Automatic fallback to single optimization if disabled"
        ],
        "_resource_scaling": {
          "memory_overhead": "Minimal - shared objective function and data",
          "cpu_utilization": "High - parallel optimization runs",
          "recommended_cores": "4+ for optimal performance"
        }
      },
      "selection_strategy": "best_chi_squared",
      "_selection_strategy_note": "best_chi_squared, consensus, or first_success when multiple methods used",
      "adaptive_target_alpha": 1.0,
      "_adaptive_target_alpha_note": "Target multiplier α for adaptive chi-squared minimization: (χ² - α·DOF)² (recommended range: 0.8-1.2)",
      "_adaptive_target_description": "Minimizes (χ² - α·DOF)² where DOF = N_data - N_params for statistically optimal fit",
      "_adaptive_target_benefits": "Prevents overfitting by targeting statistically reasonable chi-squared values"
    },
    "robust_optimization": {
      "_comment": "ENHANCED: 100x-5000x performance improvements with caching and optimized solvers",
      "_performance_upgrades": "v0.7.2+ optimizations: fast shell completion, code consolidation, improved performance",
      "_usage_examples": [
        "python run_homodyne.py --method robust  # Run only robust methods",
        "python run_homodyne.py --method classical  # Include robust in classical analysis",
        "python run_homodyne.py --method all  # Comprehensive: classical + robust + MCMC"
      ],
      "enabled": true,
      "uncertainty_model": "wasserstein",
      "_uncertainty_model_note": "Options: wasserstein (recommended), ellipsoidal, scenario",
      "uncertainty_radius": "MODE_DEPENDENT: 0.03 for static, 0.05 for laminar_flow",
      "_uncertainty_radius_note": "Fraction of data variance for uncertainty set",
      "n_scenarios": 15,
      "_n_scenarios_note": "Bootstrap scenarios - optimized for performance",
      "regularization_alpha": "MODE_DEPENDENT: 0.01 for static, 0.02 for laminar_flow",
      "_regularization_alpha_note": "L2 regularization - higher for complex parameter spaces",
      "regularization_beta": 0.001,
      "_regularization_beta_note": "L1 sparsity parameter",
      "jacobian_epsilon": 1e-06,
      "_jacobian_epsilon_note": "Finite difference step for adaptive Jacobians",
      "enable_caching": true,
      "_enable_caching_note": "Smart caching provides major performance gains",
      "preferred_solver": "CLARABEL",
      "_preferred_solver_note": "Optimized CVXPY solver: CLARABEL > SCS > CVXOPT",
      "solver_optimization": {
        "_comment": "ENHANCED v0.8.0+: Advanced CVXPY solver optimization with adaptive selection, warm-starts, and intelligent fallback",
        "enable_warm_starts": true,
        "_warm_starts_note": "Reuse previous solutions to accelerate convergence in iterative optimization",
        "adaptive_solver_selection": true,
        "_adaptive_selection_note": "Automatically select optimal solver based on problem size and structure",
        "max_iterations": 10000,
        "_max_iterations_note": "Maximum solver iterations - automatically reduced for fallback solvers",
        "tolerance": 1e-06,
        "_tolerance_note": "Solver convergence tolerance - automatically relaxed for fallback",
        "enable_acceleration": true,
        "_acceleration_note": "Enable solver acceleration techniques when available (e.g., Anderson acceleration for SCS)",
        "verbose": false,
        "time_limit": 300.0,
        "_time_limit_note": "Maximum solve time in seconds per optimization problem"
      },
      "solver_settings": {
        "_comment": "Comprehensive solver configuration for CVXPY-based robust optimization with enhanced fallback chain",
        "_solver_hierarchy": "Adaptive selection -> CLARABEL (default) -> SCS (fallback) -> ECOS -> CVXOPT (last resort)",
        "_adaptive_features": [
          "Problem size-based solver selection",
          "Warm-start capability with solution reuse",
          "Automatic parameter tuning for different solvers",
          "Intelligent fallback with reduced precision for speed",
          "Performance monitoring and solver statistics"
        ],
        "CLARABEL": {
          "_description": "Modern interior-point solver, optimized for scientific data fitting",
          "max_iter": 500,
          "tol_gap_abs": 1e-05,
          "tol_gap_rel": 1e-05,
          "tol_feas": 1e-06,
          "tol_infeas_abs": 1e-05,
          "tol_infeas_rel": 1e-05,
          "tol_ktratio": 0.0001,
          "reduced_tol_gap_abs": 0.001,
          "reduced_tol_gap_rel": 0.001,
          "reduced_tol_feas": 0.001,
          "reduced_tol_infeas_abs": 0.001,
          "reduced_tol_infeas_rel": 0.001,
          "reduced_tol_ktratio": 0.01,
          "equilibrate_enable": true,
          "equilibrate_max_iter": 30,
          "equilibrate_min_scaling": 1e-08,
          "equilibrate_max_scaling": 100000000.0,
          "direct_kkt_solver": true,
          "direct_solve_method": "qdldl",
          "static_regularization_enable": true,
          "static_regularization_constant": 1e-08,
          "static_regularization_proportional": 1e-06,
          "dynamic_regularization_enable": true,
          "dynamic_regularization_eps": 1e-13,
          "dynamic_regularization_delta": 1e-07,
          "iterative_refinement_enable": true,
          "iterative_refinement_reltol": 1e-12,
          "iterative_refinement_abstol": 1e-12,
          "iterative_refinement_max_iter": 10,
          "iterative_refinement_stop_ratio": 5.0,
          "presolve_enable": true,
          "verbose": false
        },
        "SCS": {
          "_description": "Splitting conic solver, optimized fallback for data fitting",
          "max_iters": 10000,
          "eps": 0.0001,
          "alpha": 1.8,
          "rho_x": 1e-06,
          "scale": 5.0,
          "normalize": true,
          "adaptive_scale": true,
          "use_indirect": false,
          "acceleration_lookback": 20,
          "acceleration_interval": 10,
          "write_data_filename": null,
          "log_csv_filename": null,
          "time_limit_secs": 300,
          "verbose": false
        },
        "CVXOPT": {
          "_description": "Python-based solver, stable fallback for difficult problems",
          "maxiters": 200,
          "abstol": 1e-05,
          "reltol": 0.0001,
          "feastol": 1e-05,
          "refinement": 2,
          "show_progress": false,
          "verbose": false
        },
        "GUROBI": {
          "_description": "Commercial solver optimized for scientific optimization",
          "_availability": "Requires Gurobi license",
          "Method": 2,
          "CrossOver": -1,
          "BarHomogeneous": 1,
          "BarIterLimit": 1000,
          "TimeLimit": "MODE_DEPENDENT: 300s for static, 600s for laminar_flow",
          "MIPGap": 0.001,
          "NumericFocus": 3,
          "OutputFlag": 0,
          "ScaleFlag": 3,
          "BarConvTol": 1e-06,
          "FeasibilityTol": 1e-05,
          "OptimalityTol": 1e-05,
          "MarkowitzTol": 0.1,
          "PerturbValue": 0.0002,
          "Aggregate": 1,
          "Presolve": 2,
          "PreSparsify": 1
        }
      },
      "method_options": {
        "wasserstein": {
          "uncertainty_radius": "MODE_DEPENDENT: 0.03 for static, 0.05 for laminar_flow",
          "regularization_alpha": "MODE_DEPENDENT: 0.01 for static, 0.02 for laminar_flow"
        },
        "scenario": {
          "n_scenarios": 15,
          "bootstrap_method": "residual"
        },
        "ellipsoidal": {
          "gamma": "MODE_DEPENDENT: 0.1 for static, 0.15 for laminar_flow",
          "regularization_alpha": "MODE_DEPENDENT: 0.01 for static, 0.02 for laminar_flow"
        }
      },
      "adaptive_target_alpha": 1.0,
      "_adaptive_target_alpha_note": "Target multiplier α for adaptive chi-squared minimization: (χ² - α·DOF)² (recommended range: 0.8-1.2)",
      "_adaptive_target_description": "Minimizes (χ² - α·DOF)² where DOF = N_data - N_params for statistically optimal fit",
      "_adaptive_target_benefits": "Prevents overfitting by targeting statistically reasonable chi-squared values in robust optimization"
    },
    "mcmc_sampling": {
      "_comment": "Isolated MCMC Backend Architecture - Complete separation of PyMC CPU and NumPyro GPU implementations",
      "_backend_info": {
        "architecture": "Completely isolated backends prevent PyTensor/JAX namespace conflicts",
        "cpu_backend": "Pure PyMC implementation (homodyne/optimization/mcmc_cpu_backend.py)",
        "gpu_backend": "Pure NumPyro/JAX implementation (homodyne/optimization/mcmc_gpu_backend.py)",
        "backend_selection": "Environment variable HOMODYNE_GPU_INTENT or command-based selection",
        "compatibility": "Identical API and configuration, separate execution environments"
      },
      "enabled": true,
      "sampler": "NUTS",
      "draws": "MODE_DEPENDENT: 3000 for static, 4000 for laminar_flow",
      "_draws_note": "Optimized sample count balancing accuracy and computational efficiency",
      "_large_dataset_draws": "For >1M points: 2000/3000 may be sufficient due to better statistics",
      "tune": "MODE_DEPENDENT: 800 for static, 1200 for laminar_flow",
      "_tune_note": "Sufficient tuning without excessive warmup time",
      "_large_dataset_tune": "For >5M points: 600/1000 often sufficient with good initialization",
      "thin": "MODE_DEPENDENT: 1 for static, 2 for laminar_flow",
      "_thin_note": "Minimal thinning - NUTS handles autocorrelation well",
      "_large_dataset_thin": "Large datasets: consider thin=2/3 to reduce memory usage",
      "chains": 4,
      "cores": 4,
      "target_accept": "MODE_DEPENDENT: 0.85 for static, 0.80 for laminar_flow",
      "_target_accept_note": "Balanced acceptance rate for good mixing and efficiency",
      "_large_dataset_accept": "For >10M points: 0.80/0.75 for faster sampling",
      "max_treedepth": "MODE_DEPENDENT: 8 for static, 10 for laminar_flow",
      "_max_treedepth_note": "Sufficient exploration without excessive computation",
      "_large_dataset_treedepth": "Large datasets: 6/8 may be sufficient to reduce computational cost",
      "return_inferencedata": true,
      "backend_specific": {
        "cpu_backend": {
          "_implementation": "homodyne.optimization.mcmc_cpu_backend.py",
          "_description": "Isolated PyMC implementation with complete PyTensor isolation",
          "_command": "homodyne --method mcmc (or HOMODYNE_GPU_INTENT=false)",
          "_performance": "Cross-platform compatibility, reliable convergence, no JAX conflicts",
          "_isolation": "Complete separation from JAX/NumPyro dependencies",
          "init_strategy": "adapt_diag",
          "compute_convergence_checks": true,
          "progressbar": true,
          "pytensor_config": "Automatically configured for CPU-only mode"
        },
        "gpu_backend": {
          "_implementation": "homodyne.optimization.mcmc_gpu_backend.py",
          "_description": "Isolated NumPyro/JAX implementation with complete PyMC separation",
          "_command": "homodyne-gpu --method mcmc (or HOMODYNE_GPU_INTENT=true)",
          "_performance": "GPU acceleration with intelligent CPU fallback, no PyTensor conflicts",
          "_platform_support": "Linux with CUDA preferred, auto-fallback to CPU on other platforms",
          "_isolation": "Complete separation from PyMC/PyTensor dependencies",
          "init_strategy": "init_to_value",
          "num_warmup": "Uses 'tune' parameter value",
          "num_samples": "Uses 'draws' parameter value",
          "chain_method": "vectorized",
          "progress_bar": true,
          "jit_compile": true,
          "device_memory_fraction": 0.8,
          "jax_config": "Automatically configured for optimal GPU usage"
        }
      },
      "performance_features": {
        "auto_tune_performance": true,
        "use_progressive_sampling": true,
        "use_intelligent_subsampling": true,
        "enable_jit_compilation": true,
        "memory_optimization": true
      }
    },
    "scaling_parameters": {
      "_comment": "Physical scaling: c2_fitted = c2_theory * contrast + offset",
      "fitted_range": {
        "min": 1.0,
        "max": 2.0
      },
      "theory_range": {
        "min": 0.0,
        "max": 1.0
      },
      "contrast": {
        "min": "MODE_DEPENDENT: 1e-4 for static, 0.05 for laminar_flow",
        "max": 0.5,
        "prior_mu": "MODE_DEPENDENT: 0.05 for static, 0.3 for laminar_flow",
        "prior_sigma": "MODE_DEPENDENT: 0.01 for static, 0.1 for laminar_flow",
        "type": "TruncatedNormal"
      },
      "offset": {
        "min": "MODE_DEPENDENT: 1.0 for static, 0.05 for laminar_flow",
        "max": "MODE_DEPENDENT: 1.5 for static, 1.95 for laminar_flow",
        "prior_mu": "MODE_DEPENDENT: 1.3 for static, 1.0 for laminar_flow",
        "prior_sigma": "MODE_DEPENDENT: 0.01 for static, 0.2 for laminar_flow",
        "type": "TruncatedNormal"
      }
    }
  },
  "parameter_space": {
    "_comment": "CUSTOMIZE: Parameter bounds and priors - adjust based on your physical system",
    "_bounds_note": "Parameter bounds depend on analysis_mode - see mode-specific examples below",
    "bounds": [
      {
        "_common_parameter_1": "D0",
        "name": "D0",
        "min": 1.0,
        "max": 1000000.0,
        "_customize_note": "Adjust D0 bounds based on your expected diffusion rates",
        "type": "TruncatedNormal",
        "prior_mu": 10000.0,
        "prior_sigma": 1000.0,
        "unit": "Å²/s"
      },
      {
        "_common_parameter_2": "alpha",
        "name": "alpha",
        "min": -2.0,
        "max": 2.0,
        "_customize_note": "Power-law exponent - typically [-2, 2] range is sufficient",
        "type": "Normal",
        "prior_mu": -1.5,
        "prior_sigma": 0.1,
        "unit": "dimensionless"
      },
      {
        "_common_parameter_3": "D_offset",
        "name": "D_offset",
        "min": -100,
        "max": 100,
        "_customize_note": "Baseline diffusion - adjust based on system",
        "type": "Normal",
        "prior_mu": 0.0,
        "prior_sigma": 10.0,
        "unit": "Å²/s"
      },
      {
        "_laminar_flow_parameter_4": "gamma_dot_t0 (laminar_flow mode only)",
        "name": "gamma_dot_t0",
        "min": 1e-06,
        "max": 1.0,
        "_customize_note": "Reference shear rate - adjust for your flow conditions",
        "type": "TruncatedNormal",
        "prior_mu": 0.001,
        "prior_sigma": 0.01,
        "unit": "s⁻¹"
      },
      {
        "_laminar_flow_parameter_5": "beta (laminar_flow mode only)",
        "name": "beta",
        "min": -2.0,
        "max": 2.0,
        "_customize_note": "Shear rate power-law exponent",
        "type": "Normal",
        "prior_mu": 0.0,
        "prior_sigma": 0.1,
        "unit": "dimensionless"
      },
      {
        "_laminar_flow_parameter_6": "gamma_dot_t_offset (laminar_flow mode only)",
        "name": "gamma_dot_t_offset",
        "min": -0.01,
        "max": 0.01,
        "_customize_note": "Baseline shear rate offset",
        "type": "Normal",
        "prior_mu": 0.0,
        "prior_sigma": 0.001,
        "unit": "s⁻¹"
      },
      {
        "_laminar_flow_parameter_7": "phi0 (laminar_flow mode only)",
        "name": "phi0",
        "min": -10.0,
        "max": 10.0,
        "_customize_note": "Angular offset - adjust based on geometry",
        "type": "Normal",
        "prior_mu": 0.0,
        "prior_sigma": 5.0,
        "unit": "degrees"
      }
    ]
  },
  "analysis_settings": {
    "_comment": "CUSTOMIZE: Set analysis_mode and corresponding static_mode/static_submode",
    "static_mode": "MODE_DEPENDENT: true for static_isotropic/static_anisotropic, false for laminar_flow",
    "_static_mode_note": "Controls whether to use static (3-param) or dynamic (7-param) model",
    "static_submode": "MODE_DEPENDENT: isotropic/anisotropic for static modes, null for laminar_flow",
    "_submode_note": "Isotropic disables angle filtering, anisotropic enables it",
    "model_description": {
      "static_isotropic": "g₂(t₁,t₂) ~ [exp(-q² ∫ D(t)dt)]² with isotropic symmetry",
      "static_anisotropic": "g₂(t₁,t₂) ~ [exp(-q² ∫ D(t)dt)]² with angular filtering",
      "laminar_flow": "g₂ = g₁_diff × g₁_shear with sinc² term for full flow dynamics"
    }
  },
  "advanced_settings": {
    "_comment": "Advanced computational and numerical settings",
    "data_loading": {
      "use_diagonal_correction": true,
      "vectorized_diagonal_fix": true
    },
    "chi_squared_calculation": {
      "method": "standard",
      "_scaling_note": "Scaling optimization always enabled for proper chi-squared calculation",
      "_adaptive_targeting_note": "Adaptive chi-squared targeting is configured separately in optimization_config.classical_optimization.objective_function and optimization_config.robust_optimization.objective_function",
      "minimum_sigma": 1e-10,
      "moving_window_size": 11,
      "moving_window_edge_method": "reflect",
      "variance_method": "hybrid_limited_irls",
      "_variance_method_note": "Variance estimation methods: 'irls_mad_robust' (15 iterations), 'hybrid_limited_irls' (Global MAD + Huber weights for 25-40x speedup)",
      "_variance_method_options": {
        "irls_mad_robust": "Full IRLS with MAD robust estimation (legacy method)",
        "hybrid_limited_irls": "Improved Hybrid: Global MAD + Huber robust weights + kernel smoothing (25-40x faster)"
      },
      "performance_optimization": {
        "_comment": "Simple performance settings - memory pooling removed for stability",
        "enabled": true,
        "numba_jit": {
          "enabled": true,
          "warmup_on_init": true,
          "_note": "Simple Numba JIT compilation for core computational kernels"
        }
      },
      "_moving_window_edge_method_note": "Edge handling: 'reflect' (mirror at boundaries), 'adaptive_window' (shrink at edges), 'global_fallback' (use global variance)",
      "irls_max_iterations": 15,
      "_irls_max_iterations_note": "Maximum IRLS iterations for variance convergence",
      "irls_convergence_tolerance": 0.003,
      "_irls_convergence_tolerance_note": "Relative tolerance for IRLS variance convergence",
      "irls_damping_factor": 0.8,
      "_irls_damping_factor_note": "Weight damping factor α=0.8 for stability",
      "irls_initial_sigma_squared": 0.001,
      "_irls_initial_sigma_squared_note": "Initial uniform variance for first unweighted iteration",
      "irls_min_window_size": 3,
      "_irls_min_window_size_note": "Minimum window size for reliable MAD calculation",
      "_hybrid_irls_section": "HYBRID LIMITED-ITERATION IRLS PARAMETERS (FGLS-inspired approach)",
      "hybrid_irls_max_iterations": 2,
      "_hybrid_irls_max_iterations_note": "Maximum IRLS iterations for improved approach (1-2 iterations typical)",
      "hybrid_irls_convergence_tolerance": 0.01,
      "_hybrid_irls_convergence_tolerance_note": "Convergence tolerance for improved IRLS (relaxed due to faster convergence)",
      "fast_computation": true,
      "uncertainty_calculation": {
        "enable_uncertainty": true,
        "report_uncertainty": true,
        "minimum_angles_for_uncertainty": "MODE_DEPENDENT: 1 for static_isotropic, 2+ for others"
      },
      "validity_check": {
        "check_positive_D0": true,
        "check_positive_gamma_dot_t0": "MODE_DEPENDENT: false for static modes, true for laminar_flow",
        "check_positive_time_dependent": true,
        "check_parameter_bounds": true
      },
      "_improved_hybrid_irls_section": "IMPROVED HYBRID IRLS PARAMETERS (Global MAD + Huber Weights)",
      "huber_constant_factor": 1.345,
      "_huber_constant_factor_note": "Huber threshold factor for 95% efficiency (1.345 standard for robust statistics)",
      "kernel_bandwidth_scale": 0.2,
      "_kernel_bandwidth_scale_note": "Bandwidth scaling for kernel smoothing (0.1-0.3 range, affects local variance trends)",
      "regularization_strength": 0.15,
      "_regularization_strength_note": "Regularization strength λ for local/global variance blending (0.1-0.2 typical)"
    },
    "numerical_integration": {
      "method": "simpson",
      "relative_tolerance": 1e-08,
      "absolute_tolerance": 1e-12
    },
    "optimization_controls": {
      "convergence_tolerance": 1e-08,
      "max_function_evaluations": "MODE_DEPENDENT: 5000 for static, 15000 for laminar_flow",
      "_max_function_evaluations_note": "Higher limits for complex parameter spaces",
      "parameter_scaling": "auto",
      "finite_difference_step": 1e-08
    }
  },
  "performance_settings": {
    "_comment": "Performance optimization settings with mode-dependent scaling",
    "caching": {
      "enable_memory_cache": true,
      "enable_disk_cache": true,
      "cache_size_limit_mb": "MODE_DEPENDENT: 500-750 for static, 1000 for laminar_flow",
      "auto_cleanup": true
    },
    "parallel_processing": {
      "enable_multiprocessing": true,
      "chunk_size": "auto",
      "backend": "threading"
    },
    "memory_management": {
      "low_memory_mode": false,
      "garbage_collection_frequency": 10,
      "memory_monitoring": false
    },
    "numba_optimization": {
      "enable_numba": true,
      "warmup_numba": true,
      "parallel_numba": true,
      "cache_numba": true,
      "stability_enhancements": {
        "enable_kernel_warmup": true,
        "warmup_iterations": "MODE_DEPENDENT: 3 for static, 5 for laminar_flow",
        "optimize_memory_layout": true,
        "enable_nogil": true,
        "environment_optimization": {
          "auto_configure": true,
          "max_threads": "MODE_DEPENDENT: 2-3 for static, 4 for laminar_flow",
          "gc_optimization": true
        }
      },
      "performance_monitoring": {
        "enable_profiling": false,
        "stable_benchmarking": false,
        "adaptive_benchmarking": false,
        "performance_baselines": false,
        "target_cv": 0.1,
        "memory_monitoring": true,
        "smart_caching": {
          "enabled": true,
          "max_items": "MODE_DEPENDENT: 50-75 for static, 100 for laminar_flow",
          "max_memory_mb": "MODE_DEPENDENT: 250-375 for static, 500 for laminar_flow"
        }
      }
    },
    "noise_model": {
      "use_simple_forward_model": false,
      "_note": "False uses full forward model consistent with classical optimization",
      "sigma_prior": 0.1
    }
  },
  "validation_rules": {
    "_comment": "Quality control and validation thresholds",
    "data_quality": {
      "check_data_range": true,
      "correlation_minimum": 0.0,
      "correlation_maximum": 10.0,
      "check_nan_values": true,
      "nan_handling": "raise"
    },
    "parameter_validation": {
      "check_bounds": true,
      "physics_constraints": true,
      "correlation_checks": true
    },
    "fit_quality": {
      "_comment": "Chi-squared quality thresholds - adjust based on your data quality expectations",
      "overall_chi_squared": {
        "excellent_threshold": 5.0,
        "acceptable_threshold": 10.0,
        "warning_threshold": 20.0,
        "critical_threshold": 50.0
      },
      "per_angle_chi_squared": {
        "excellent_threshold": 5.0,
        "acceptable_threshold": 10.0,
        "warning_threshold": 20.0,
        "outlier_threshold_multiplier": 2.5,
        "max_outlier_fraction": 0.25,
        "min_good_angles": "MODE_DEPENDENT: 1 for static_isotropic, 2-3 for others"
      }
    },
    "mcmc_convergence": {
      "_comment": "MCMC convergence diagnostics - tighter for complex parameter spaces",
      "rhat_thresholds": {
        "excellent_threshold": 1.01,
        "good_threshold": 1.05,
        "acceptable_threshold": 1.1,
        "critical_threshold": 1.2
      },
      "ess_thresholds": {
        "excellent_threshold": 400,
        "good_threshold": 200,
        "acceptable_threshold": 100,
        "minimum_threshold": 50
      },
      "divergence_thresholds": {
        "max_divergences_fraction": 0.05,
        "warning_divergences_fraction": 0.01
      }
    },
    "frame_range": {
      "minimum_frames": 10,
      "maximum_frames": null,
      "check_continuity": true
    }
  },
  "workflow_integration": {
    "_comment": "Analysis workflow and integration settings",
    "analysis_workflow": {
      "auto_generate_plots": true,
      "plot_integration_enabled": true,
      "plot_experimental_data_on_load": false,
      "cache_plot_data": true,
      "save_intermediate_plots": false
    },
    "mcmc_integration": {
      "auto_save_traces": true,
      "trace_file_format": "netcdf",
      "include_warmup_in_traces": false,
      "convergence_diagnostics_auto": true,
      "plot_mcmc_results": true
    },
    "data_management": {
      "experimental_data_cache": true,
      "theoretical_data_cache": true,
      "cache_directory": "./cache",
      "auto_cleanup_cache": false,
      "cache_retention_days": 30
    },
    "error_handling": {
      "continue_on_plot_errors": true,
      "log_plot_errors": true,
      "fallback_plotting": true,
      "validate_plot_data": true
    }
  },
  "output_settings": {
    "_comment": "Output and reporting configuration",
    "_output_structure": "homodyne_analysis_results.json (main summary) saved to output directory root. Method-specific results in subdirectories: classical/[method_name]/ and robust/[method_name]/ containing analysis_results_[method_name].json, parameters.json, fitted_data.npz (c2_experimental, c2_fitted, residuals, parameters, uncertainties, chi_squared, phi_angles, t1, t2), and c2_heatmaps_[method_name].png. Summary files: all_classical_methods_summary.json, all_robust_methods_summary.json. MCMC results in mcmc/ subdirectory.",
    "results_directory": "./homodyne_results",
    "file_formats": {
      "results_format": "json",
      "save_intermediate": false,
      "compression": true,
      "precision": "float64"
    },
    "file_naming": {
      "timestamp_format": "%Y%m%d_%H%M%S",
      "include_config_name": true,
      "include_chi_squared": true
    },
    "reporting": {
      "generate_plots": true,
      "plot_formats": [
        "png",
        "pdf"
      ],
      "detailed_summary": true,
      "convergence_diagnostics": true
    },
    "plotting": {
      "_comment": "Comprehensive plotting configuration with method-specific outputs",
      "general": {
        "create_plots": true,
        "plot_format": "png",
        "dpi": 300,
        "figure_size": "MODE_DEPENDENT: [10,8] for static, [12,8] for laminar_flow",
        "_figsize_note": "Larger figures for complex parameter results",
        "style": "publication",
        "save_plots": true,
        "show_plots": false
      },
      "c2_heatmaps": {
        "enabled": true,
        "_method_specific_note": "Separate heatmaps generated for each optimization method (Nelder-Mead, Gurobi, Robust-*, etc.) with method names in filenames",
        "layout": "single_row",
        "include_experimental": true,
        "include_theoretical": true,
        "include_residuals": true,
        "colormap": "viridis",
        "colorbar_position": "right",
        "title_prefix": "MODE_DEPENDENT: C2 Correlation Function ([analysis_mode])",
        "figsize": "MODE_DEPENDENT: [12,4] for static_isotropic, [15,5] for static_anisotropic, [18,6] for laminar_flow"
      },
      "mcmc_plots": {
        "enabled": true,
        "corner_plots": {
          "enabled": true,
          "show_titles": true,
          "quantiles": [
            0.16,
            0.5,
            0.84
          ],
          "show_truths": false,
          "use_arviz": true,
          "figsize": "MODE_DEPENDENT: [9,9] for static, [15,15] for laminar_flow"
        },
        "trace_plots": {
          "enabled": true,
          "show_chains": true,
          "show_warmup": false,
          "compact_layout": "MODE_DEPENDENT: true for static, false for laminar_flow",
          "figsize": "MODE_DEPENDENT: [10,6] for static, [12,14] for laminar_flow"
        },
        "convergence_diagnostics": {
          "enabled": true,
          "show_rhat": true,
          "show_ess": true,
          "show_mcse": true,
          "show_energy": true,
          "rhat_threshold": 1.1,
          "ess_threshold": 100
        }
      },
      "diagnostic_plots": {
        "enabled": true,
        "chi_squared_summary": true,
        "parameter_correlations": true,
        "residual_analysis": true,
        "convergence_history": true
      },
      "output": {
        "base_directory": "./plots",
        "subdirectories": {
          "c2_heatmaps": "c2_correlation",
          "parameter_plots": "parameters",
          "mcmc_plots": "mcmc_analysis",
          "diagnostics": "diagnostics"
        },
        "filename_template": "{analysis_type}_{start_frame}_{end_frame}_{method}_{timestamp}",
        "_filename_template_note": "Frame-aware plotting with method identification: start_frame, end_frame for data range, method name (Nelder-Mead, Gurobi-Iterative-QP, Robust-Wasserstein, etc.), timestamp",
        "include_timestamp": true,
        "overwrite_existing": false
      }
    },
    "logging": {
      "log_level": "INFO",
      "log_to_file": true,
      "log_to_console": true,
      "log_filename": "MODE_DEPENDENT: homodyne_[analysis_mode].log",
      "rotation": {
        "max_bytes": 10485760,
        "backup_count": 3
      },
      "optimization_debug": {
        "enabled": false,
        "log_frequency": 10,
        "include_residuals": true,
        "include_chi_squared": true,
        "performance_mode": false,
        "_optimization_debug_note": "Enhanced optimization logging for debugging convergence behavior",
        "_log_frequency_note": "Log every N iterations (set to 1 for all iterations, higher values for less frequent logging)",
        "_include_residuals_note": "Include min/mean/max residual statistics in optimization logs",
        "_include_chi_squared_note": "Include reduced chi-squared values in optimization progress logs",
        "_performance_mode_note": "Set to true to disable detailed logging for production runs"
      },
      "mcmc_debug": {
        "enabled": false,
        "sampling_progress": true,
        "convergence_monitoring": true,
        "chain_diagnostics": true,
        "chi_squared_tracking": true,
        "residual_statistics": false,
        "log_frequency": 100,
        "performance_mode": false,
        "_mcmc_debug_note": "Comprehensive MCMC debugging and progress monitoring",
        "_sampling_progress_note": "Log sampling progress during NUTS iterations",
        "_convergence_monitoring_note": "Monitor and log R-hat, ESS, and convergence diagnostics",
        "_chain_diagnostics_note": "Track chain mixing, divergences, and sampling efficiency",
        "_chi_squared_tracking_note": "Log reduced chi-squared evolution during sampling",
        "_residual_statistics_note": "Include min/mean/max residual statistics (may impact performance)",
        "_mcmc_log_frequency_note": "Log every N draws during sampling (100 = every 100 draws)",
        "_mcmc_performance_mode_note": "Minimal logging for production MCMC runs"
      },
      "mcmc_gpu_debug": {
        "enabled": false,
        "device_monitoring": true,
        "memory_tracking": true,
        "compilation_logging": false,
        "backend_switching": true,
        "performance_profiling": false,
        "jax_debugging": false,
        "sampling_progress": true,
        "convergence_monitoring": true,
        "chain_diagnostics": true,
        "chi_squared_tracking": true,
        "log_frequency": 100,
        "performance_mode": false,
        "_mcmc_gpu_debug_note": "Comprehensive GPU MCMC debugging with JAX/NumPyro specific monitoring",
        "_device_monitoring_note": "Track GPU device usage, utilization, and switching between devices",
        "_memory_tracking_note": "Monitor GPU memory allocation, usage patterns, and potential OOM conditions",
        "_compilation_logging_note": "Log JAX JIT compilation events, kernel caching, and recompilation triggers",
        "_backend_switching_note": "Track automatic fallback from GPU to CPU and reasons for backend changes",
        "_performance_profiling_note": "Detailed GPU performance metrics: samples/sec, memory efficiency, compute utilization",
        "_jax_debugging_note": "Enable JAX debugging features: NaN checks, device placement validation",
        "_gpu_sampling_progress_note": "Log GPU-specific sampling progress with device and memory information",
        "_gpu_convergence_monitoring_note": "GPU-accelerated R-hat, ESS computations with performance tracking",
        "_gpu_chain_diagnostics_note": "Track GPU chain mixing with vectorized computation metrics",
        "_gpu_chi_squared_note": "GPU-accelerated chi-squared tracking with device placement logging",
        "_gpu_log_frequency_note": "GPU logging frequency (higher values recommended for performance)",
        "_gpu_performance_mode_note": "Minimal GPU logging for production runs with maximum performance"
      }
    }
  },
  "_customization_guide": {
    "_step_1": "Set analysis_mode in metadata section to: static_isotropic, static_anisotropic, or laminar_flow",
    "_step_2": "Update experimental_data section with your file paths and sample name",
    "_step_3": "Customize analyzer_parameters: dt (time step), q (wavevector), frame range, gap size",
    "_step_4": "Adjust initial_parameters values based on your expected parameter ranges",
    "_step_5": "Modify parameter_space bounds to match your physical system constraints",
    "_step_6": "Update analysis_settings: set static_mode and static_submode consistently with analysis_mode",
    "_step_7": "Adjust performance_settings based on your computational resources",
    "_step_8": "Customize validation_rules thresholds based on your data quality expectations",
    "_step_9": "Update output_settings paths and logging configuration",
    "_mode_dependent_values": "Search for 'MODE_DEPENDENT' throughout config to see values that need mode-specific customization"
  },
  "_recent_enhancements": {
    "_gurobi_optimization": "Enhanced Trust Region SQP algorithm fixes χ² convergence issues in v0.7.1+",
    "_robust_optimization": "100x-5000x performance improvements with smart caching and optimized solvers",
    "_interactive_mode": "Completely removed - replaced with argcomplete shell completion",
    "_code_quality": "Full codebase formatted with black, linted with flake8, type-checked with mypy",
    "_dependency_management": "Updated pyproject.toml with 'completion' group instead of deprecated 'interactive'",
    "_test_coverage": "Enhanced test suite with better CLI completion testing and error handling"
  }
}