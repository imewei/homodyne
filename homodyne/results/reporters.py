"""
Comprehensive Report Generation for Homodyne v2
===============================================

Publication-ready report generation system with multiple output formats,
LaTeX integration, and automated figure/table generation.

Key Features:
- Multi-format report generation (HTML, PDF, Markdown, LaTeX)
- Automated figure and table integration
- Template-based report layouts
- Publication-ready formatting
- Interactive HTML reports with plots
- Scientific citation formatting
"""

from typing import Dict, Any, List, Optional, Union, Tuple
from pathlib import Path
from datetime import datetime
import json
import os
from dataclasses import dataclass

from homodyne.utils.logging import get_logger
from homodyne.optimization.variational import VIResult
from homodyne.optimization.mcmc import MCMCResult
from homodyne.optimization.hybrid import HybridResult
from homodyne.results.summarizers import AnalysisSummarizer, SummaryLevel
from homodyne.results.formatters import ResultFormatter

logger = get_logger(__name__)

ResultType = Union[VIResult, MCMCResult, HybridResult]


@dataclass
class ReportConfig:
    """
    Report generation configuration.
    
    Attributes:
        format: Output format ('html', 'pdf', 'markdown', 'latex')
        include_plots: Include analysis plots
        include_tables: Include detailed tables
        template_style: Template style ('scientific', 'technical', 'executive')
        custom_css: Custom CSS file path (HTML only)
        bibliography: Bibliography file path (optional)
    """
    format: str = 'html'
    include_plots: bool = True
    include_tables: bool = True
    template_style: str = 'scientific'
    custom_css: Optional[str] = None
    bibliography: Optional[str] = None


class ReportTemplate:
    """
    Report template base class.
    
    Provides structure and formatting for different report types
    with extensible template system.
    """
    
    def __init__(self, style: str = 'scientific'):
        """
        Initialize report template.
        
        Args:
            style: Template style ('scientific', 'technical', 'executive')
        """
        self.style = style
        self.template_dir = Path(__file__).parent / 'templates'
        
    def get_header(self, title: str, authors: List[str] = None) -> str:
        """
        Get report header section.
        
        Args:
            title: Report title
            authors: List of authors (optional)
            
        Returns:
            Formatted header string
        """
        authors = authors or []
        
        if self.style == 'scientific':
            return self._scientific_header(title, authors)
        elif self.style == 'technical':
            return self._technical_header(title, authors)
        else:  # executive
            return self._executive_header(title, authors)
    
    def get_section(self, title: str, content: str, level: int = 2) -> str:
        """
        Get formatted section.
        
        Args:
            title: Section title
            content: Section content
            level: Heading level (1-6)
            
        Returns:
            Formatted section string
        """
        raise NotImplementedError("Subclasses must implement get_section")
    
    def get_footer(self) -> str:
        """
        Get report footer section.
        
        Returns:
            Formatted footer string
        """
        return f"\n---\n*Generated by Homodyne v2 on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n"
    
    def _scientific_header(self, title: str, authors: List[str]) -> str:
        """Generate scientific paper style header."""
        header = f"# {title}\n\n"
        if authors:
            header += f"**Authors:** {', '.join(authors)}\n\n"
        header += f"**Date:** {datetime.now().strftime('%B %d, %Y')}\n\n"
        return header
    
    def _technical_header(self, title: str, authors: List[str]) -> str:
        """Generate technical report style header."""
        return f"# {title}\n\n**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
    
    def _executive_header(self, title: str, authors: List[str]) -> str:
        """Generate executive summary style header."""
        return f"# Executive Report: {title}\n\n**Date:** {datetime.now().strftime('%B %d, %Y')}\n\n"


class MarkdownTemplate(ReportTemplate):
    """Markdown report template."""
    
    def get_section(self, title: str, content: str, level: int = 2) -> str:
        """Get Markdown formatted section."""
        heading = "#" * level
        return f"\n{heading} {title}\n\n{content}\n"
    
    def format_table(self, data: Dict[str, Any], caption: str = "") -> str:
        """Format table in Markdown."""
        if not data:
            return ""
        
        # Simple key-value table
        table = "| Parameter | Value |\n|-----------|-------|\n"
        for key, value in data.items():
            table += f"| {key} | {value} |\n"
        
        if caption:
            table += f"\n*{caption}*\n"
        
        return table
    
    def format_figure(self, figure_path: str, caption: str = "") -> str:
        """Format figure reference in Markdown."""
        figure_md = f"![{caption}]({figure_path})\n"
        if caption:
            figure_md += f"\n*Figure: {caption}*\n"
        return figure_md


class HTMLTemplate(ReportTemplate):
    """HTML report template with CSS styling."""
    
    def __init__(self, style: str = 'scientific', custom_css: Optional[str] = None):
        super().__init__(style)
        self.custom_css = custom_css
    
    def get_html_header(self, title: str) -> str:
        """Get HTML document header."""
        css = self._get_css_styles()
        
        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
{css}
    </style>
</head>
<body>
<div class="container">
"""
    
    def get_html_footer(self) -> str:
        """Get HTML document footer."""
        return f"""
<div class="footer">
    <p><em>Generated by Homodyne v2 on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</em></p>
</div>
</div>
</body>
</html>"""
    
    def get_section(self, title: str, content: str, level: int = 2) -> str:
        """Get HTML formatted section."""
        return f'<section class="level-{level}"><h{level}>{title}</h{level}><div class="content">{content}</div></section>\n'
    
    def format_table(self, data: Dict[str, Any], caption: str = "", table_class: str = "data-table") -> str:
        """Format table in HTML."""
        if not data:
            return ""
        
        html = f'<table class="{table_class}">\n'
        html += '<thead><tr><th>Parameter</th><th>Value</th></tr></thead>\n<tbody>\n'
        
        for key, value in data.items():
            html += f'<tr><td>{key}</td><td>{value}</td></tr>\n'
        
        html += '</tbody>\n</table>\n'
        
        if caption:
            html = f'<div class="table-container"><p class="caption">{caption}</p>\n{html}</div>\n'
        
        return html
    
    def format_figure(self, figure_path: str, caption: str = "", figure_class: str = "analysis-figure") -> str:
        """Format figure in HTML."""
        html = f'<div class="figure-container">\n'
        html += f'<img src="{figure_path}" alt="{caption}" class="{figure_class}">\n'
        if caption:
            html += f'<p class="figure-caption">Figure: {caption}</p>\n'
        html += '</div>\n'
        return html
    
    def _get_css_styles(self) -> str:
        """Get CSS styles for HTML report."""
        if self.custom_css and Path(self.custom_css).exists():
            return Path(self.custom_css).read_text()
        
        return """
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            line-height: 1.6; 
            color: #333; 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .container { 
            background: white; 
            padding: 30px; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
        }
        
        h1, h2, h3 { 
            color: #2c3e50; 
            border-bottom: 2px solid #3498db; 
            padding-bottom: 10px; 
        }
        
        .data-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 20px 0; 
            background: white;
        }
        
        .data-table th, .data-table td { 
            border: 1px solid #ddd; 
            padding: 12px; 
            text-align: left; 
        }
        
        .data-table th { 
            background-color: #3498db; 
            color: white; 
            font-weight: bold;
        }
        
        .data-table tr:nth-child(even) { 
            background-color: #f9f9f9; 
        }
        
        .figure-container { 
            text-align: center; 
            margin: 30px 0; 
            padding: 20px; 
            border: 1px solid #eee; 
            border-radius: 8px;
        }
        
        .analysis-figure { 
            max-width: 100%; 
            height: auto; 
            border-radius: 4px;
        }
        
        .figure-caption, .caption { 
            font-style: italic; 
            color: #666; 
            margin-top: 10px; 
        }
        
        .footer { 
            text-align: center; 
            margin-top: 50px; 
            padding-top: 20px; 
            border-top: 1px solid #eee; 
            color: #666;
        }
        
        .level-2 { 
            margin: 30px 0; 
            padding: 20px; 
            background: #f8f9fa; 
            border-left: 4px solid #3498db;
        }
        
        .content {
            margin-top: 15px;
        }
        """


class ReportGenerator:
    """
    Comprehensive report generator with multiple output formats.
    
    Generates publication-ready reports with automated content generation,
    figure integration, and template-based formatting.
    """
    
    def __init__(self, output_dir: Union[str, Path]):
        """
        Initialize report generator.
        
        Args:
            output_dir: Output directory for reports
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        self.summarizer = AnalysisSummarizer()
        self.formatter = ResultFormatter()
        
        # Available templates
        self.templates = {
            'markdown': MarkdownTemplate,
            'html': HTMLTemplate
        }
    
    def generate_report(self,
                       result: ResultType,
                       config: ReportConfig,
                       title: str = None,
                       data_dict: Dict[str, Any] = None,
                       plot_paths: Dict[str, str] = None) -> Path:
        """
        Generate comprehensive analysis report.
        
        Args:
            result: Analysis result to report on
            config: Report configuration
            title: Report title (optional)
            data_dict: Original experimental data (optional)
            plot_paths: Dictionary of plot file paths (optional)
            
        Returns:
            Path to generated report file
        """
        logger.info(f"📄 Generating {config.format.upper()} analysis report")
        
        # Generate title if not provided
        if title is None:
            method_name = result.__class__.__name__.replace('Result', '')
            analysis_mode = getattr(result, 'analysis_mode', 'unknown')
            title = f"{method_name} Analysis Report - {analysis_mode.replace('_', ' ').title()}"
        
        # Create analysis summary
        summary_level = self._get_summary_level(config.template_style)
        summary = self.summarizer.create_summary(result, summary_level)
        
        # Generate report based on format
        if config.format == 'html':
            return self._generate_html_report(result, config, title, summary, plot_paths)
        elif config.format == 'markdown':
            return self._generate_markdown_report(result, config, title, summary, plot_paths)
        elif config.format == 'pdf':
            return self._generate_pdf_report(result, config, title, summary, plot_paths)
        elif config.format == 'latex':
            return self._generate_latex_report(result, config, title, summary, plot_paths)
        else:
            raise ValueError(f"Unsupported report format: {config.format}")
    
    def _generate_html_report(self,
                             result: ResultType,
                             config: ReportConfig,
                             title: str,
                             summary: Any,
                             plot_paths: Dict[str, str] = None) -> Path:
        """Generate HTML report."""
        template = HTMLTemplate(config.template_style, config.custom_css)
        
        output_file = self.output_dir / f"analysis_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        
        with open(output_file, 'w', encoding='utf-8') as f:
            # HTML header
            f.write(template.get_html_header(title))
            
            # Report title
            f.write(f'<h1>{title}</h1>\n')
            f.write(f'<p class="subtitle">Generated on {datetime.now().strftime("%B %d, %Y at %H:%M:%S")}</p>\n')
            
            # Summary sections
            for section in summary.sections:
                section_content = self._format_section_content(section, template, plot_paths)
                f.write(template.get_section(section.title, section_content))
            
            # Key findings if available
            if summary.key_findings:
                findings_content = '<ul class="key-findings">\n'
                for finding in summary.key_findings:
                    findings_content += f'<li>{finding}</li>\n'
                findings_content += '</ul>\n'
                f.write(template.get_section("Key Findings", findings_content))
            
            # Include plots if requested
            if config.include_plots and plot_paths:
                plots_content = self._create_plots_section(template, plot_paths)
                f.write(template.get_section("Analysis Plots", plots_content))
            
            # HTML footer
            f.write(template.get_html_footer())
        
        logger.info(f"✓ HTML report saved: {output_file}")
        return output_file
    
    def _generate_markdown_report(self,
                                 result: ResultType,
                                 config: ReportConfig,
                                 title: str,
                                 summary: Any,
                                 plot_paths: Dict[str, str] = None) -> Path:
        """Generate Markdown report."""
        template = MarkdownTemplate(config.template_style)
        
        output_file = self.output_dir / f"analysis_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        
        with open(output_file, 'w', encoding='utf-8') as f:
            # Header
            f.write(template.get_header(title))
            
            # Summary sections
            for section in summary.sections:
                section_content = self._format_section_content(section, template, plot_paths)
                f.write(template.get_section(section.title, section_content))
            
            # Key findings
            if summary.key_findings:
                f.write(template.get_section("Key Findings", "\n".join(f"- {finding}" for finding in summary.key_findings)))
            
            # Include plots if requested
            if config.include_plots and plot_paths:
                plots_content = self._create_plots_section(template, plot_paths)
                f.write(template.get_section("Analysis Plots", plots_content))
            
            # Footer
            f.write(template.get_footer())
        
        logger.info(f"✓ Markdown report saved: {output_file}")
        return output_file
    
    def _generate_pdf_report(self,
                           result: ResultType,
                           config: ReportConfig,
                           title: str,
                           summary: Any,
                           plot_paths: Dict[str, str] = None) -> Path:
        """Generate PDF report (requires pandoc or similar)."""
        # First generate markdown, then convert to PDF
        md_config = ReportConfig(format='markdown', template_style=config.template_style)
        md_file = self._generate_markdown_report(result, md_config, title, summary, plot_paths)
        
        output_file = self.output_dir / f"analysis_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
        
        try:
            # Try to convert using pandoc
            import subprocess
            cmd = ['pandoc', str(md_file), '-o', str(output_file), '--pdf-engine=xelatex']
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info(f"✓ PDF report saved: {output_file}")
                return output_file
            else:
                logger.error(f"PDF conversion failed: {result.stderr}")
                
        except (ImportError, FileNotFoundError):
            logger.warning("Pandoc not available for PDF conversion. Install pandoc for PDF support.")
        
        # Fallback: return markdown file
        logger.info(f"✓ Markdown report saved (PDF conversion unavailable): {md_file}")
        return md_file
    
    def _generate_latex_report(self,
                              result: ResultType,
                              config: ReportConfig,
                              title: str,
                              summary: Any,
                              plot_paths: Dict[str, str] = None) -> Path:
        """Generate LaTeX report."""
        output_file = self.output_dir / f"analysis_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.tex"
        
        with open(output_file, 'w', encoding='utf-8') as f:
            # LaTeX preamble
            f.write(self._get_latex_preamble())
            
            # Document start
            f.write("\\begin{document}\n")
            f.write(f"\\title{{{title}}}\n")
            f.write(f"\\date{{{datetime.now().strftime('%B %d, %Y')}}}\n")
            f.write("\\maketitle\n\n")
            
            # Summary sections
            for section in summary.sections:
                f.write(f"\\section{{{section.title}}}\n")
                content = self._format_latex_content(section)
                f.write(f"{content}\n\n")
            
            # Document end
            f.write("\\end{document}\n")
        
        logger.info(f"✓ LaTeX report saved: {output_file}")
        return output_file
    
    def _format_section_content(self, section: Any, template: ReportTemplate, plot_paths: Dict[str, str] = None) -> str:
        """Format section content for specific template."""
        content = section.content
        
        if isinstance(content, dict):
            if isinstance(template, HTMLTemplate):
                return template.format_table(content)
            elif isinstance(template, MarkdownTemplate):
                return template.format_table(content)
            else:
                # Fallback to string representation
                return json.dumps(content, indent=2)
        elif isinstance(content, str):
            return content
        else:
            return str(content)
    
    def _create_plots_section(self, template: ReportTemplate, plot_paths: Dict[str, str]) -> str:
        """Create plots section for report."""
        if not plot_paths:
            return "No plots available."
        
        plots_content = ""
        for plot_name, plot_path in plot_paths.items():
            caption = self._generate_plot_caption(plot_name)
            
            if isinstance(template, HTMLTemplate):
                plots_content += template.format_figure(plot_path, caption)
            elif isinstance(template, MarkdownTemplate):
                plots_content += template.format_figure(plot_path, caption)
        
        return plots_content
    
    def _generate_plot_caption(self, plot_name: str) -> str:
        """Generate descriptive caption for plot."""
        caption_map = {
            'c2_experimental_heatmap': 'Experimental correlation function C₂(φ,t₁,t₂)',
            'c2_fitted_heatmap': 'Fitted correlation function with optimized parameters',
            'residuals_heatmap': 'Residuals between experimental and fitted data',
            'parameter_evolution': 'Parameter evolution during optimization',
            'convergence_plot': 'Convergence diagnostics and quality metrics'
        }
        
        return caption_map.get(plot_name, plot_name.replace('_', ' ').title())
    
    def _get_summary_level(self, template_style: str) -> SummaryLevel:
        """Get appropriate summary level for template style."""
        level_map = {
            'executive': SummaryLevel.EXECUTIVE,
            'technical': SummaryLevel.TECHNICAL,
            'scientific': SummaryLevel.DETAILED
        }
        return level_map.get(template_style, SummaryLevel.TECHNICAL)
    
    def _get_latex_preamble(self) -> str:
        """Get LaTeX document preamble."""
        return """\\documentclass[11pt,a4paper]{article}
\\usepackage[utf8]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage{amsmath,amssymb}
\\usepackage{graphicx}
\\usepackage{booktabs}
\\usepackage{hyperref}
\\usepackage{geometry}
\\geometry{margin=1in}

\\title{Homodyne Analysis Report}
\\author{Generated by Homodyne v2}

"""
    
    def _format_latex_content(self, section: Any) -> str:
        """Format content for LaTeX."""
        content = section.content
        
        if isinstance(content, dict):
            # Create LaTeX table
            latex_content = "\\begin{tabular}{ll}\n\\toprule\nParameter & Value \\\\\n\\midrule\n"
            for key, value in content.items():
                latex_content += f"{key} & {value} \\\\\n"
            latex_content += "\\bottomrule\n\\end{tabular}\n"
            return latex_content
        elif isinstance(content, str):
            # Escape LaTeX special characters
            content = content.replace('_', '\\_').replace('%', '\\%').replace('&', '\\&')
            return content
        else:
            return str(content)
    
    def generate_batch_reports(self,
                              results: List[Tuple[ResultType, str]],
                              config: ReportConfig,
                              comparison_title: str = "Batch Analysis Report") -> List[Path]:
        """
        Generate batch reports for multiple results.
        
        Args:
            results: List of (result, name) tuples
            config: Report configuration
            comparison_title: Title for comparison report
            
        Returns:
            List of generated report file paths
        """
        logger.info(f"📚 Generating batch reports for {len(results)} analyses")
        
        report_paths = []
        
        # Generate individual reports
        for result, name in results:
            individual_config = ReportConfig(
                format=config.format,
                template_style=config.template_style,
                include_plots=config.include_plots,
                include_tables=config.include_tables
            )
            
            report_path = self.generate_report(
                result=result,
                config=individual_config,
                title=f"Analysis Report: {name}"
            )
            report_paths.append(report_path)
        
        logger.info(f"✓ Generated {len(report_paths)} individual reports")
        return report_paths
    
    def get_available_templates(self) -> List[str]:
        """
        Get list of available report templates.
        
        Returns:
            List of available template names
        """
        return list(self.templates.keys())
    
    def validate_config(self, config: ReportConfig) -> bool:
        """
        Validate report configuration.
        
        Args:
            config: Report configuration to validate
            
        Returns:
            True if configuration is valid
        """
        valid_formats = ['html', 'markdown', 'pdf', 'latex']
        valid_styles = ['scientific', 'technical', 'executive']
        
        if config.format not in valid_formats:
            logger.error(f"Invalid report format: {config.format}")
            return False
        
        if config.template_style not in valid_styles:
            logger.error(f"Invalid template style: {config.template_style}")
            return False
        
        if config.custom_css and not Path(config.custom_css).exists():
            logger.warning(f"Custom CSS file not found: {config.custom_css}")
        
        return True