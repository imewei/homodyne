{
  "metadata": {
    "_comment": "Project metadata for homodyne analysis testing",
    "config_version": "0.7.2",
    "description": "General Homodyne Analysis Configuration for Testing",
    "based_on": "He et al. PNAS 2024 - Transport coefficient approach",
    "analysis_mode": "static_anisotropic",
    "created_date": "2025-08-20",
    "updated_date": "2025-01-22",
    "authors": ["Wei Chen"],
    "institution": "Argonne National Laboratory",
    "experiment_name": "Test Suite",
    "sample_description": "Testing Configuration",
    "shell_completion": "Use argcomplete for shell completion (conda environments auto-enabled)",
    "script_compatibility": "homodyne v0.7.2",
    "_cli_usage": {
      "description": "CLI usage for general homodyne analysis",
      "recommended_commands": [
        "homodyne --config homodyne_config.json --method classical",
        "homodyne --config homodyne_config.json --method all",
        "homodyne --config homodyne_config.json --method mcmc"
      ]
    }
  },
  "experimental_data": {
    "_comment": "Data configuration for testing",
    "description": "Test data source configuration",
    "data_folder_path": "./data/Simon/",
    "data_file_name": "test_data_file.hdf",
    "phi_angles_path": "./data/Simon/",
    "phi_angles_file": "phi_list.txt",
    "exchange_key": "exchange",
    "cache_file_path": "./data/Simon/",
    "cache_filename_template": "cached_c2_test_frames_{start_frame}_{end_frame}.npz",
    "cache_compression": true,
    "data_type": "float64",
    "file_format": "NPZ",
    "preprocessing": {
      "_comment": "Standard preprocessing settings",
      "apply_diagonal_correction": true,
      "vectorized_correction": true,
      "cache_processed_data": true,
      "normalize_data": true,
      "normalization_method": "baseline"
    }
  },
  "analyzer_parameters": {
    "_comment": "Analysis parameters for testing",
    "temporal": {
      "dt": 0.5,
      "_dt_note": "Time step for analysis",
      "dt_unit": "seconds",
      "start_frame": 400,
      "end_frame": 1000
    },
    "scattering": {
      "wavevector_q": 0.0237,
      "_wavevector_q_note": "q-vector magnitude",
      "q_unit": "Å⁻¹"
    },
    "geometry": {
      "_comment": "Geometry parameters",
      "stator_rotor_gap": 2000000,
      "gap_unit": "Å",
      "_gap_note": "Stator-rotor gap parameter"
    },
    "computational": {
      "num_threads": 4,
      "auto_detect_cores": true,
      "max_threads_limit": 8,
      "memory_limit_gb": 4
    }
  },
  "initial_parameters": {
    "_comment": "Initial parameters for optimization",
    "description": "Starting values for all model parameters",
    "values": [1000, -0.5, 100, 0.1, -0.1, 0.01, 15.0],
    "parameter_names": [
      "D0",
      "alpha",
      "D_offset",
      "gamma_dot_t0",
      "beta",
      "gamma_dot_t_offset",
      "phi0"
    ],
    "units": [
      "Å²/s",
      "dimensionless",
      "Å²/s",
      "s⁻¹",
      "dimensionless",
      "s⁻¹",
      "degrees"
    ],
    "parameter_units": {
      "D0": "Å²/s",
      "alpha": "dimensionless",
      "D_offset": "Å²/s",
      "gamma_dot_t0": "s⁻¹",
      "beta": "dimensionless",
      "gamma_dot_t_offset": "s⁻¹",
      "phi0": "degrees"
    },
    "active_parameters": [
      "D0",
      "alpha",
      "D_offset",
      "gamma_dot_t0",
      "beta",
      "gamma_dot_t_offset",
      "phi0"
    ]
  },
  "optimization_config": {
    "_comment": "Optimization configuration",
    "angle_filtering": {
      "_comment": "Angle filtering settings",
      "enabled": true,
      "target_ranges": [
        [10, 30],
        [45, 75]
      ],
      "fallback_to_all_angles": true
    },
    "classical_optimization": {
      "methods": [
        "Nelder-Mead",
        "Gurobi",
        "Robust-Wasserstein",
        "Robust-Scenario",
        "Robust-Ellipsoidal"
      ],
      "_methods_note": "Available: Nelder-Mead (always), Gurobi (if licensed), Robust-* (if CVXPY installed)",
      "_cli_usage": {
        "--method classical": "Runs ALL 5 methods above (classical + robust)",
        "--method robust": "Runs ONLY Robust-Wasserstein, Robust-Scenario, Robust-Ellipsoidal",
        "--method all": "Runs classical methods + MCMC (if available)"
      },
      "_gurobi_availability": "Gurobi provides quadratic programming alternative. Requires license: pip install gurobipy",
      "_robust_availability": "Robust methods require CVXPY: pip install cvxpy. Options: Robust-Wasserstein, Robust-Scenario, Robust-Ellipsoidal",
      "method_options": {
        "Nelder-Mead": {
          "maxiter": 5000,
          "xatol": 1e-8,
          "fatol": 1e-8,
          "adaptive": true
        },
        "Gurobi": {
          "_comment": "Gurobi quadratic programming optimization options (requires Gurobi license)",
          "max_iterations": 1000,
          "_max_iterations_note": "Maximum number of optimization iterations",
          "tolerance": 1e-6,
          "_tolerance_note": "Convergence tolerance for optimization",
          "output_flag": 0,
          "_output_flag_note": "Gurobi output verbosity (0=silent, 1=normal)",
          "method": 2,
          "_method_note": "Gurobi solution method (2=barrier method recommended for QP)",
          "time_limit": 300,
          "_time_limit_note": "Time limit in seconds for optimization",
          "_usage_note": "Gurobi uses quadratic approximation via finite differences. Best for smooth objective functions with bounds constraints.",
          "_advantages": "Handles bounds constraints naturally, can be faster for well-conditioned problems",
          "_disadvantages": "Requires license, uses quadratic approximation which may not capture all nonlinearity"
        }
      },
      "robust_optimization": {
        "_comment": "Robust optimization settings using CVXPY + Gurobi",
        "_example_usage": [
          "python run_homodyne.py --method robust --static-anisotropic  # Robust in static mode",
          "python run_homodyne.py --method classical  # All 5 methods including robust"
        ],
        "solver_config": {
          "primary_solver": "GUROBI",
          "fallback_solver": "ECOS",
          "solver_options": {
            "_comment": "Gurobi solver configuration optimized for XPCS problems",
            "OutputFlag": 0,
            "TimeLimit": 300,
            "MIPGap": 1e-4,
            "NumericFocus": 3,
            "Presolve": 2,
            "Method": 2,
            "_OutputFlag_note": "0=silent, 1=normal output",
            "_TimeLimit_note": "Maximum solve time in seconds",
            "_MIPGap_note": "Mixed-integer gap tolerance",
            "_NumericFocus_note": "3=maximum numerical precision",
            "_Presolve_note": "2=aggressive presolve for better performance",
            "_Method_note": "Gurobi solver method: 2=Barrier, 0=Primal simplex, 1=Dual simplex"
          }
        },
        "methods": {
          "Robust-Wasserstein": {
            "_description": "Distributionally Robust Optimization with Wasserstein uncertainty sets",
            "uncertainty_radius": 0.1,
            "regularization_alpha": 0.01,
            "_uncertainty_radius_note": "Wasserstein uncertainty set radius (0.05-0.2 typical)",
            "_regularization_alpha_note": "L2 regularization parameter for stability"
          },
          "Robust-Scenario": {
            "_description": "Scenario-based robust optimization with bootstrap resampling",
            "n_scenarios": 15,
            "scenario_generation": "bootstrap",
            "confidence_level": 0.95,
            "_n_scenarios_note": "Number of worst-case scenarios to consider (20-100 typical)",
            "_scenario_generation_note": "Method: bootstrap, monte_carlo, or grid_based",
            "_confidence_level_note": "Statistical confidence level for robustness"
          },
          "Robust-Ellipsoidal": {
            "_description": "Ellipsoidal uncertainty sets with confidence bounds",
            "uncertainty_set": "ellipsoidal",
            "ellipsoid_radius": 0.15,
            "confidence_level": 0.95,
            "_ellipsoid_radius_note": "Ellipsoidal uncertainty set radius",
            "_confidence_level_note": "Statistical confidence level for uncertainty bounds"
          }
        },
        "_performance_note": "Robust methods typically 2-5x slower than classical but provide uncertainty resistance",
        "_requirements": "Requires CVXPY (pip install cvxpy). Gurobi license recommended for best performance."
      },
      "selection_strategy": "best_chi_squared",
      "_selection_strategy_note": "How to choose best result when multiple methods are used: best_chi_squared, consensus, first_success"
    },
    "mcmc_sampling": {
      "_comment": "Isolated MCMC Backend Configuration for Testing - Lightweight settings for test suite",
      "_backend_architecture": {
        "isolation": "Complete separation of PyMC CPU and NumPyro GPU implementations",
        "cpu_implementation": "homodyne.optimization.mcmc_cpu_backend.py",
        "gpu_implementation": "homodyne.optimization.mcmc_gpu_backend.py",
        "conflict_prevention": "Eliminates PyTensor/JAX namespace conflicts through isolated execution",
        "testing_focus": "Reduced sampling for fast test execution"
      },
      "enabled": true,
      "sampler": "NUTS",
      "draws": 2000,
      "tune": 500,
      "thin": 1,
      "chains": 2,
      "cores": 2,
      "target_accept": 0.95,
      "max_treedepth": 10,
      "return_inferencedata": true,
      "backend_specific": {
        "cpu_backend": {
          "_implementation": "homodyne.optimization.mcmc_cpu_backend.py",
          "_description": "Isolated PyMC implementation for testing - no JAX dependencies",
          "_command": "homodyne --method mcmc (or HOMODYNE_GPU_INTENT=false)",
          "_isolation": "Pure PyMC environment, complete separation from NumPyro/JAX",
          "init_strategy": "adapt_diag",
          "compute_convergence_checks": true,
          "progressbar": true,
          "pytensor_config": "Automatically configured for test environment"
        },
        "gpu_backend": {
          "_implementation": "homodyne.optimization.mcmc_gpu_backend.py",
          "_description": "Isolated NumPyro/JAX implementation for testing - no PyMC dependencies",
          "_command": "homodyne-gpu --method mcmc (or HOMODYNE_GPU_INTENT=true)",
          "_platform_support": "Linux with CUDA preferred, intelligent fallback for testing",
          "_isolation": "Pure NumPyro/JAX environment, complete separation from PyMC/PyTensor",
          "init_strategy": "init_to_value",
          "chain_method": "vectorized",
          "progress_bar": true,
          "jit_compile": true,
          "device_memory_fraction": 0.8
        }
      },
      "performance_features": {
        "auto_tune_performance": true,
        "use_progressive_sampling": true,
        "use_intelligent_subsampling": true,
        "enable_jit_compilation": true,
        "memory_optimization": true
      }
    },
    "scaling_parameters": {
      "_comment": "Physical scaling constraints for c2 fitting",
      "fitted_range": {
        "min": 1.0,
        "max": 2.0,
        "_description": "c2_fitted = c2_theory * contrast + offset, must be in [1,2]"
      },
      "theory_range": {
        "min": 0.0,
        "max": 1.0,
        "_description": "c2_theory normalized correlation function, must be in [0,1]"
      },
      "contrast": {
        "min": 0.05,
        "max": 0.5,
        "prior_mu": 0.3,
        "prior_sigma": 0.1,
        "type": "TruncatedNormal",
        "_description": "Scaling factor for correlation strength, typically ∈ (0, 0.5]"
      },
      "offset": {
        "min": 0.05,
        "max": 1.95,
        "prior_mu": 1.0,
        "prior_sigma": 0.2,
        "type": "TruncatedNormal",
        "_description": "Baseline correlation level, typically ∈ (0, 2.0), μ ≈ 1.0"
      }
    }
  },
  "parameter_space": {
    "_comment": "Parameter bounds for optimization",
    "bounds": [
      {
        "name": "D0",
        "min": 1.0,
        "max": 1000000,
        "type": "TruncatedNormal",
        "prior_mu": 10000.0,
        "prior_sigma": 1000.0,
        "unit": "Å²/s",
        "physical_constraint": "positive"
      },
      {
        "name": "alpha",
        "min": -2.0,
        "max": 2.0,
        "type": "Normal",
        "prior_mu": -1.5,
        "prior_sigma": 0.1,
        "unit": "dimensionless",
        "physical_constraint": "none"
      },
      {
        "name": "D_offset",
        "min": -100,
        "max": 100,
        "type": "Normal",
        "prior_mu": 0.0,
        "prior_sigma": 10.0,
        "unit": "Å²/s",
        "physical_constraint": "none"
      },
      {
        "name": "gamma_dot_t0",
        "min": 1e-6,
        "max": 1.0,
        "type": "TruncatedNormal",
        "prior_mu": 0.001,
        "prior_sigma": 0.01,
        "unit": "s⁻¹",
        "physical_constraint": "positive"
      },
      {
        "name": "beta",
        "min": -2.0,
        "max": 2.0,
        "type": "Normal",
        "prior_mu": 0.0,
        "prior_sigma": 0.1,
        "unit": "dimensionless",
        "physical_constraint": "none"
      },
      {
        "name": "gamma_dot_t_offset",
        "min": -0.01,
        "max": 0.01,
        "type": "Normal",
        "prior_mu": 0.0,
        "prior_sigma": 0.001,
        "unit": "s⁻¹",
        "physical_constraint": "none"
      },
      {
        "name": "phi0",
        "min": -10,
        "max": 10,
        "type": "Normal",
        "prior_mu": 0.0,
        "prior_sigma": 5.0,
        "unit": "degrees",
        "physical_constraint": "none"
      }
    ]
  },
  "analysis_settings": {
    "_comment": "Analysis mode settings",
    "static_mode": false,
    "static_submode": "anisotropic",
    "model_description": {
      "current_mode": "laminar_flow",
      "equation": "g₁(t₁,t₂) = exp(-q² ∫ᵗ²ᵗ¹ D(t)dt) × sinc²(∫ᵗ²ᵗ¹ γ̇(t)dt)",
      "description": "Full laminar flow model with diffusion and shear contributions"
    }
  },
  "advanced_settings": {
    "data_loading": {
      "use_diagonal_correction": true,
      "vectorized_diagonal_fix": true
    },
    "chi_squared_calculation": {
      "method": "standard",
      "minimum_sigma": 1e-10,
      "fast_computation": true,
      "validity_check": {
        "check_positive_D0": true,
        "check_positive_gamma_dot_t0": true,
        "check_positive_time_dependent": true,
        "check_parameter_bounds": true
      },
      "variance_method": "irls_mad_robust",
      "_variance_method_note": "Options: irls_mad_robust (default), irls_optimized (50x faster), mad_robust, mad_optimized (10x faster)",
      "irls_config": {
        "max_iterations": 5,
        "damping_factor": 0.7,
        "convergence_tolerance": 0.0001,
        "initial_sigma_squared": 0.001,
        "_algorithm_note": "IRLS with MAD: \u03c3\u00b2\u1d62 = (1.4826 \u00d7 MAD)\u00b2, damping: \u03c3\u00b2 = \u03b1\u00b7\u03c3\u00b2_new + (1-\u03b1)\u00b7\u03c3\u00b2_prev",
        "optimized_config": {
          "use_vectorized_mad": true,
          "use_quickselect_median": true,
          "enable_jit_compilation": true,
          "parallel_window_processing": true
        }
      },
      "performance_optimization": {
        "_comment": "Performance optimization settings for chi-squared and IRLS calculations",
        "enabled": true,
        "variance_estimator": "irls_optimized",
        "_variance_estimator_note": "irls_optimized provides 50-100x speedup via JIT compilation and vectorization",
        "chi_calculator": "vectorized_jit",
        "_chi_calculator_note": "vectorized_jit provides 20-50x speedup with memory pooling",
        "median_algorithm": "quickselect",
        "_median_algorithm_note": "quickselect provides 5-10x speedup over numpy median for small arrays",
        "jit_compilation": {
          "enabled": true,
          "warmup_on_init": true,
          "parallel_processing": true,
          "fastmath": true,
          "cache_kernels": true
        },
        "memory_optimization": {
          "use_memory_pool": true,
          "pool_size_mb": 256,
          "adaptive_caching": true,
          "cache_strategy": "lru",
          "max_cache_items": 100
        },
        "parallel_threads": {
          "enabled": true,
          "thread_count": "auto",
          "chunk_size": "adaptive",
          "backend": "threading"
        }
      }
    }
  },
  "performance_settings": {
    "caching": {
      "enable_memory_cache": true,
      "enable_disk_cache": true,
      "cache_size_limit_mb": 500,
      "auto_cleanup": true
    },
    "parallel_processing": {
      "enable_multiprocessing": true,
      "chunk_size": "auto",
      "backend": "threading"
    }
  },
  "output_settings": {
    "reporting": {
      "generate_plots": true,
      "plot_formats": ["png"],
      "detailed_summary": true
    },
    "plotting": {
      "general": {
        "create_plots": true,
        "plot_format": "png",
        "dpi": 150,
        "figure_size": [8, 6],
        "style": "default"
      },
      "c2_heatmaps": {
        "enabled": true,
        "layout": "grid",
        "include_experimental": true,
        "include_theoretical": true,
        "include_residuals": true
      },
      "mcmc_plots": {
        "enabled": true,
        "corner_plots": {
          "enabled": true,
          "figsize": [10, 10]
        },
        "trace_plots": {
          "enabled": true,
          "figsize": [12, 8]
        }
      }
    }
  },
  "validation_rules": {
    "_comment": "Validation rules for analysis quality",
    "fit_quality": {
      "_comment": "Classical optimization fit quality thresholds",
      "overall_chi_squared": {
        "excellent_threshold": 2.0,
        "acceptable_threshold": 5.0,
        "warning_threshold": 10.0,
        "critical_threshold": 20.0
      },
      "per_angle_chi_squared": {
        "excellent_threshold": 2.0,
        "acceptable_threshold": 5.0,
        "warning_threshold": 10.0,
        "outlier_threshold_multiplier": 2.5,
        "max_outlier_fraction": 0.25,
        "min_good_angles": 3
      }
    },
    "mcmc_convergence": {
      "_comment": "MCMC convergence validation",
      "rhat_thresholds": {
        "excellent_threshold": 1.01,
        "good_threshold": 1.05,
        "acceptable_threshold": 1.1,
        "critical_threshold": 1.15
      },
      "ess_thresholds": {
        "excellent_threshold": 400,
        "good_threshold": 200,
        "acceptable_threshold": 100,
        "minimum_threshold": 50
      },
      "divergence_thresholds": {
        "max_divergences_fraction": 0.02,
        "warning_divergences_fraction": 0.01
      }
    },
    "parameter_validation": {
      "_comment": "Parameter validation settings",
      "check_bounds": true,
      "physics_constraints": true,
      "correlation_checks": true
    }
  }
}
